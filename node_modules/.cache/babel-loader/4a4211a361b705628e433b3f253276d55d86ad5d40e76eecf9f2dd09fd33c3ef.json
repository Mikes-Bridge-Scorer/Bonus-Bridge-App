{"ast":null,"code":"/**\r\n * Utility functions for bridge scoring calculations\r\n */\n\n/**\r\n * Parse a contract string into its components\r\n * @param {string} contractString - The contract string (e.g., \"4♥ N\")\r\n * @param {number} result - The result (positive for made contracts, negative for defeated)\r\n * @param {Object} vulnerable - Vulnerability object with ns and ew properties\r\n * @returns {Object} Contract details\r\n */\nexport const parseContract = (contractString, result, vulnerable) => {\n  if (!contractString) return null;\n  const contractMatch = contractString.match(/(\\d)([♣♦♥♠]|NT)\\s+([NESW])(X{0,2})/);\n  if (!contractMatch) return null;\n  const level = parseInt(contractMatch[1]);\n  const suit = contractMatch[2];\n  const declarer = contractMatch[3];\n  const doubled = contractMatch[4] || '';\n  const isNS = declarer === 'N' || declarer === 'S';\n  const vulnerableNS = (vulnerable === null || vulnerable === void 0 ? void 0 : vulnerable.ns) || false;\n  const vulnerableEW = (vulnerable === null || vulnerable === void 0 ? void 0 : vulnerable.ew) || false;\n  const declarerVulnerable = isNS ? vulnerableNS : vulnerableEW;\n  const requiredTricks = level + 6;\n  const actualTricks = requiredTricks + (result || 0);\n  const madeContract = result >= 0;\n  return {\n    level,\n    suit,\n    declarer,\n    doubled,\n    isNS,\n    declarerVulnerable,\n    requiredTricks,\n    actualTricks,\n    madeContract,\n    result: result || 0\n  };\n};\n\n/**\r\n * Calculate standard bridge score\r\n * @param {Object} contractDetails - Contract details object from parseContract\r\n * @returns {Object} Scoring object with nsPoints and ewPoints\r\n */\nexport const calculateBridgeScore = contractDetails => {\n  if (!contractDetails) return {\n    nsPoints: 0,\n    ewPoints: 0\n  };\n  const {\n    level,\n    suit,\n    isNS,\n    declarerVulnerable,\n    madeContract,\n    result,\n    doubled\n  } = contractDetails;\n  let score = 0;\n\n  // Calculate score for made contracts\n  if (madeContract) {\n    // Base trick score\n    let trickScore = 0;\n    if (suit === '♣' || suit === '♦') {\n      // Minor suits: 20 points per trick\n      trickScore = level * 20;\n    } else if (suit === '♥' || suit === '♠') {\n      // Major suits: 30 points per trick\n      trickScore = level * 30;\n    } else if (suit === 'NT') {\n      // No Trump: 40 for first trick, 30 for additional tricks\n      trickScore = 40 + (level - 1) * 30;\n    }\n\n    // Apply doubling if applicable\n    if (doubled === 'X') {\n      trickScore *= 2;\n    } else if (doubled === 'XX') {\n      trickScore *= 4;\n    }\n    score += trickScore;\n\n    // Add bonus for game contracts (100 non-vul, 120 vul)\n    if (score >= 100) {\n      score += declarerVulnerable ? 120 : 50;\n    } else {\n      // Partial contract bonus\n      score += 50;\n    }\n\n    // Slam bonuses\n    if (level === 6) {\n      // Small slam bonus\n      score += declarerVulnerable ? 750 : 500;\n    } else if (level === 7) {\n      // Grand slam bonus\n      score += declarerVulnerable ? 1500 : 1000;\n    }\n\n    // Doubled/redoubled bonus\n    if (doubled === 'X') {\n      score += 50;\n    } else if (doubled === 'XX') {\n      score += 100;\n    }\n\n    // Overtrick points\n    if (result > 0) {\n      let overtrickPoints = 0;\n      if (doubled === 'X') {\n        // Doubled overtricks\n        overtrickPoints = result * (declarerVulnerable ? 200 : 100);\n      } else if (doubled === 'XX') {\n        // Redoubled overtricks\n        overtrickPoints = result * (declarerVulnerable ? 400 : 200);\n      } else {\n        // Undoubled overtricks\n        if (suit === '♣' || suit === '♦') {\n          overtrickPoints = result * 20;\n        } else {\n          overtrickPoints = result * 30;\n        }\n      }\n      score += overtrickPoints;\n    }\n  } else {\n    // Score for defeated contracts\n    let undertrickPoints = 0;\n    if (doubled === 'X') {\n      // Doubled undertricks\n      if (declarerVulnerable) {\n        // Vulnerable doubled undertricks\n        undertrickPoints = 200 + (Math.abs(result) - 1) * 300;\n      } else {\n        // Non-vulnerable doubled undertricks\n        undertrickPoints = 100 + (Math.abs(result) > 1 ? 200 : 0) + (Math.abs(result) > 2 ? (Math.abs(result) - 2) * 300 : 0);\n      }\n    } else if (doubled === 'XX') {\n      // Redoubled undertricks (double the doubled undertricks)\n      if (declarerVulnerable) {\n        undertrickPoints = 400 + (Math.abs(result) - 1) * 600;\n      } else {\n        undertrickPoints = 200 + (Math.abs(result) > 1 ? 400 : 0) + (Math.abs(result) > 2 ? (Math.abs(result) - 2) * 600 : 0);\n      }\n    } else {\n      // Undoubled undertricks\n      undertrickPoints = Math.abs(result) * (declarerVulnerable ? 100 : 50);\n    }\n    score = -undertrickPoints;\n  }\n\n  // Assign points to the appropriate side\n  if (isNS) {\n    return {\n      nsPoints: madeContract ? score : 0,\n      ewPoints: madeContract ? 0 : -score\n    };\n  } else {\n    return {\n      nsPoints: madeContract ? 0 : -score,\n      ewPoints: madeContract ? score : 0\n    };\n  }\n};\n\n/**\r\n * Generate a readable vulnerability description\r\n * @param {Object} vulnerable - Vulnerability object with ns and ew properties\r\n * @returns {string} Description of vulnerability\r\n */\nexport const vulnerabilityDescription = vulnerable => {\n  if (!vulnerable) return \"None Vulnerable\";\n  const nsVul = vulnerable.ns || false;\n  const ewVul = vulnerable.ew || false;\n  if (nsVul && ewVul) return \"All Vulnerable\";\n  if (nsVul) return \"NS Vulnerable\";\n  if (ewVul) return \"EW Vulnerable\";\n  return \"None Vulnerable\";\n};\n\n/**\r\n * Determine vulnerability based on deal number\r\n * @param {number} dealNumber - Current deal number\r\n * @returns {Object} Vulnerability object with ns and ew properties\r\n */\nexport const determineVulnerability = dealNumber => {\n  if (!dealNumber) return {\n    ns: false,\n    ew: false\n  };\n\n  // Standard bridge vulnerability rotation based on deal number\n  const vulPattern = (dealNumber - 1) % 16;\n  switch (vulPattern) {\n    case 0:\n    case 7:\n    case 10:\n    case 13:\n      return {\n        ns: false,\n        ew: false\n      };\n    // None Vulnerable\n    case 1:\n    case 4:\n    case 11:\n    case 14:\n      return {\n        ns: true,\n        ew: false\n      };\n    // NS Vulnerable\n    case 2:\n    case 5:\n    case 8:\n    case 15:\n      return {\n        ns: false,\n        ew: true\n      };\n    // EW Vulnerable\n    case 3:\n    case 6:\n    case 9:\n    case 12:\n      return {\n        ns: true,\n        ew: true\n      };\n    // Both Vulnerable\n    default:\n      return {\n        ns: false,\n        ew: false\n      };\n    // Default to None Vulnerable\n  }\n};\n\n/**\r\n * Determine dealer based on deal number\r\n * @param {number} dealNumber - Current deal number\r\n * @returns {string} Dealer position (North, East, South, West)\r\n */\nexport const determineDealer = dealNumber => {\n  const positions = [\"North\", \"East\", \"South\", \"West\"];\n  const index = (dealNumber - 1) % 4;\n  return positions[index];\n};\n\n/**\r\n * Check if a contract is a game contract\r\n * @param {Object} contractDetails - Contract details from parseContract\r\n * @returns {boolean} True if the contract is a game contract\r\n */\nexport const isGameContract = contractDetails => {\n  if (!contractDetails) return false;\n  const {\n    level,\n    suit\n  } = contractDetails;\n  return level === 3 && suit === 'NT' || level === 4 && (suit === '♥' || suit === '♠') || level === 5 && (suit === '♣' || suit === '♦') || level >= 6;\n};\n\n/**\r\n * Calculate bonus bridge score based on the enhanced scoring system\r\n * @param {Object} contractDetails - Contract details from parseContract\r\n * @param {Object} handAnalysis - Hand analysis data (HCP, distribution, etc.)\r\n * @returns {Object} Bonus bridge scoring object\r\n */\nexport const calculateBonusBridgeScore = (contractDetails, handAnalysis) => {\n  if (!contractDetails || !handAnalysis) return {\n    nsPoints: 0,\n    ewPoints: 0\n  };\n  const {\n    level,\n    suit,\n    isNS,\n    declarerVulnerable,\n    madeContract,\n    result,\n    doubled,\n    actualTricks,\n    requiredTricks\n  } = contractDetails;\n  const {\n    totalHCP,\n    singletons,\n    voids,\n    longSuits\n  } = handAnalysis;\n  let declarerPoints = 0;\n  let defenderPoints = 0;\n\n  // Get standard bridge score for raw score calculation\n  const standardScore = calculateBridgeScore(contractDetails);\n\n  // Extract raw score (absolute value)\n  const rawScore = Math.abs(madeContract ? isNS ? standardScore.nsPoints : standardScore.ewPoints : isNS ? standardScore.ewPoints : standardScore.nsPoints);\n  if (madeContract) {\n    // ***** STEP 1: Calculate Raw Score and Reduce Scale *****\n    const initialPoints = rawScore / 20;\n\n    // ***** STEP 2: Calculate HCP Advantage *****\n    const declarerHCPPercentage = totalHCP / 40 * 100;\n    const defenderHCPPercentage = 100 - declarerHCPPercentage;\n    const hcpAdvantage = Math.abs(declarerHCPPercentage - defenderHCPPercentage);\n    const advantageSide = declarerHCPPercentage > 50 ? \"declarer\" : \"defender\";\n\n    // ***** STEP 3: Apply HCP Adjustment Based on Contract Type *****\n    let expectedHCP;\n\n    // Determine Expected HCP based on contract type\n    if (level <= 2) {\n      // Part Scores (1-2 level)\n      expectedHCP = 21;\n    } else if (level === 3 && suit === 'NT') {\n      // 3NT Game\n      expectedHCP = 25;\n    } else if (level === 4 && (suit === '♥' || suit === '♠')) {\n      // 4♥/♠ Game\n      expectedHCP = 24;\n    } else if (level === 5 && (suit === '♣' || suit === '♦')) {\n      // 5♣/♦ Game\n      expectedHCP = 27;\n    } else if (level === 6) {\n      // Small Slams (6 level)\n      expectedHCP = 30;\n    } else if (level === 7) {\n      // Grand Slams (7 level)\n      expectedHCP = 32;\n    } else {\n      // Other levels\n      expectedHCP = 21 + level * 1.5;\n    }\n\n    // Calculate adjustment\n    const hcpAdjustment = (totalHCP - expectedHCP) * 0.75;\n    let adjustedPoints = initialPoints;\n    if (totalHCP > expectedHCP) {\n      // If Declarer HCP > Expected HCP: Subtract adjustment\n      adjustedPoints -= hcpAdjustment;\n    } else if (totalHCP < expectedHCP) {\n      // If Declarer HCP < Expected HCP: Add adjustment\n      adjustedPoints += Math.abs(hcpAdjustment);\n    }\n    // No adjustment if Declarer HCP = Expected HCP\n\n    // ***** STEP 4: Calculate Expected Tricks *****\n    const contractExpectedTricks = requiredTricks;\n    const distributionPoints = voids * 3 + singletons * 2 + longSuits;\n    const handExpectedTricks = Math.min(13, 6 + Math.floor(totalHCP / 3) + Math.floor(distributionPoints / 4));\n\n    // ***** STEP 5: Performance Assessment *****\n    let performancePoints = adjustedPoints;\n\n    // For Contract Performance\n    const performanceVariance = actualTricks - contractExpectedTricks;\n    if (performanceVariance > 0) {\n      // If Variance > 0 (overtricks): Add (Variance × 1.5) points\n      performancePoints += performanceVariance * 1.5;\n    }\n\n    // For Hand Potential Performance (only if Hand Expected > Contract Expected)\n    if (handExpectedTricks > contractExpectedTricks) {\n      const potentialVariance = actualTricks - handExpectedTricks;\n      if (potentialVariance < 0) {\n        // If Potential Variance < 0 (underperformance): Subtract (|Potential Variance| × 0.75) points\n        performancePoints -= Math.abs(potentialVariance) * 0.75;\n      }\n    }\n\n    // ***** STEP 6: Apply Contract Type Adjustments *****\n    let contractPoints = performancePoints;\n\n    // Check if it's a Game contract\n    const isGameContractVal = isGameContract(contractDetails);\n    if (isGameContractVal) {\n      // For Game contracts\n      contractPoints += 2;\n    }\n    if (level === 6) {\n      // For Small Slam contracts\n      contractPoints += 4;\n    } else if (level === 7) {\n      // For Grand Slam contracts\n      contractPoints += 6;\n    }\n    if (suit === 'NT') {\n      // For NT contracts\n      contractPoints += 1;\n    }\n    const overtricks = actualTricks - contractExpectedTricks;\n    if (overtricks >= 4) {\n      // For contracts with 4+ overtricks\n      contractPoints += 1;\n      if (overtricks >= 7) {\n        // For contracts with 7+ overtricks\n        contractPoints += 2;\n      }\n    }\n\n    // ***** STEP 7: Distribution Adjustment (Suit Contracts Only) *****\n    let finalDeclarerPoints = contractPoints;\n    if (suit !== 'NT') {\n      // Only apply for suit contracts\n      if (distributionPoints >= 7) {\n        finalDeclarerPoints -= 3;\n      } else if (distributionPoints >= 5) {\n        finalDeclarerPoints -= 2;\n      } else if (distributionPoints >= 3) {\n        finalDeclarerPoints -= 1;\n      }\n      // 1-2 dist points: No deduction\n    }\n\n    // ***** STEP 8: Defender Reward Calculation *****\n    if (handExpectedTricks > contractExpectedTricks && actualTricks < handExpectedTricks) {\n      // Defender Reward = (Hand Expected Tricks - Actual Tricks) × 2\n      const defenderReward = (handExpectedTricks - actualTricks) * 2;\n\n      // Extra reward if defending at disadvantage\n      const extraReward = Math.min(3, hcpAdvantage / 10);\n      defenderPoints = defenderReward + (advantageSide === \"declarer\" ? extraReward : 0);\n    }\n\n    // ***** STEP 9: Finalize Scores *****\n    declarerPoints = Math.max(1, Math.round(finalDeclarerPoints)); // Minimum declarer score for made contracts: 1 point\n    defenderPoints = Math.round(defenderPoints);\n  } else {\n    // ***** SCORING FOR DEFEATED CONTRACTS *****\n\n    // ***** STEP 1: Calculate Base Penalty *****\n    const basePenalty = rawScore / 10;\n\n    // ***** STEP 2: Add Contract Level Penalties *****\n    let levelPenalties = 0;\n\n    // Check if it's a Game contract\n    const isGameContractVal = isGameContract(contractDetails);\n    if (isGameContractVal) {\n      // For defeated Game contracts\n      levelPenalties += 3;\n    }\n    if (level === 6) {\n      // For defeated Small Slams\n      levelPenalties += 5;\n    } else if (level === 7) {\n      // For defeated Grand Slams\n      levelPenalties += 7;\n    }\n\n    // ***** STEP 3: Calculate Defender Performance Bonus *****\n    let performanceBonus = 0;\n    const declarerHCPPercentage = totalHCP / 40 * 100;\n    if (declarerHCPPercentage > 60) {\n      // If Declarer HCP% > 60%\n      performanceBonus += (declarerHCPPercentage - 50) / 5;\n    }\n    if (Math.abs(result) >= 2) {\n      // If contract defeated by 2+ tricks\n      performanceBonus += 2;\n      if (Math.abs(result) >= 3) {\n        // If contract defeated by 3+ tricks\n        performanceBonus += 3;\n      }\n    }\n\n    // ***** STEP 4: Calculate Declarer Consolation (Optional) *****\n    let consolationPoints = 0;\n    if (declarerHCPPercentage < 40) {\n      // If Declarer HCP% < 40%\n      consolationPoints = (50 - declarerHCPPercentage) / 10;\n    }\n\n    // ***** STEP 5: Finalize Scores for Defeated Contracts *****\n    const totalDefenderPoints = basePenalty + levelPenalties + performanceBonus;\n    defenderPoints = Math.max(3, Math.round(totalDefenderPoints)); // Minimum defender score: 3 points\n    declarerPoints = Math.round(consolationPoints);\n  }\n\n  // Return final scores for NS and EW\n  if (isNS) {\n    return {\n      nsPoints: madeContract ? declarerPoints : declarerPoints,\n      ewPoints: madeContract ? defenderPoints : defenderPoints,\n      rawScore\n    };\n  } else {\n    return {\n      nsPoints: madeContract ? defenderPoints : defenderPoints,\n      ewPoints: madeContract ? declarerPoints : declarerPoints,\n      rawScore\n    };\n  }\n};","map":{"version":3,"names":["parseContract","contractString","result","vulnerable","contractMatch","match","level","parseInt","suit","declarer","doubled","isNS","vulnerableNS","ns","vulnerableEW","ew","declarerVulnerable","requiredTricks","actualTricks","madeContract","calculateBridgeScore","contractDetails","nsPoints","ewPoints","score","trickScore","overtrickPoints","undertrickPoints","Math","abs","vulnerabilityDescription","nsVul","ewVul","determineVulnerability","dealNumber","vulPattern","determineDealer","positions","index","isGameContract","calculateBonusBridgeScore","handAnalysis","totalHCP","singletons","voids","longSuits","declarerPoints","defenderPoints","standardScore","rawScore","initialPoints","declarerHCPPercentage","defenderHCPPercentage","hcpAdvantage","advantageSide","expectedHCP","hcpAdjustment","adjustedPoints","contractExpectedTricks","distributionPoints","handExpectedTricks","min","floor","performancePoints","performanceVariance","potentialVariance","contractPoints","isGameContractVal","overtricks","finalDeclarerPoints","defenderReward","extraReward","max","round","basePenalty","levelPenalties","performanceBonus","consolationPoints","totalDefenderPoints"],"sources":["C:/Users/mikec/MikesBridge/bonusbridge/src/utils/scoring.js"],"sourcesContent":["/**\r\n * Utility functions for bridge scoring calculations\r\n */\r\n\r\n/**\r\n * Parse a contract string into its components\r\n * @param {string} contractString - The contract string (e.g., \"4♥ N\")\r\n * @param {number} result - The result (positive for made contracts, negative for defeated)\r\n * @param {Object} vulnerable - Vulnerability object with ns and ew properties\r\n * @returns {Object} Contract details\r\n */\r\nexport const parseContract = (contractString, result, vulnerable) => {\r\n  if (!contractString) return null;\r\n  \r\n  const contractMatch = contractString.match(/(\\d)([♣♦♥♠]|NT)\\s+([NESW])(X{0,2})/);\r\n  if (!contractMatch) return null;\r\n  \r\n  const level = parseInt(contractMatch[1]);\r\n  const suit = contractMatch[2];\r\n  const declarer = contractMatch[3];\r\n  const doubled = contractMatch[4] || '';\r\n  \r\n  const isNS = declarer === 'N' || declarer === 'S';\r\n  const vulnerableNS = vulnerable?.ns || false;\r\n  const vulnerableEW = vulnerable?.ew || false;\r\n  \r\n  const declarerVulnerable = isNS ? vulnerableNS : vulnerableEW;\r\n  const requiredTricks = level + 6;\r\n  const actualTricks = requiredTricks + (result || 0);\r\n  const madeContract = result >= 0;\r\n  \r\n  return {\r\n    level,\r\n    suit,\r\n    declarer,\r\n    doubled,\r\n    isNS,\r\n    declarerVulnerable,\r\n    requiredTricks,\r\n    actualTricks,\r\n    madeContract,\r\n    result: result || 0\r\n  };\r\n};\r\n\r\n/**\r\n * Calculate standard bridge score\r\n * @param {Object} contractDetails - Contract details object from parseContract\r\n * @returns {Object} Scoring object with nsPoints and ewPoints\r\n */\r\nexport const calculateBridgeScore = (contractDetails) => {\r\n  if (!contractDetails) return { nsPoints: 0, ewPoints: 0 };\r\n  \r\n  const {\r\n    level,\r\n    suit,\r\n    isNS,\r\n    declarerVulnerable,\r\n    madeContract,\r\n    result,\r\n    doubled\r\n  } = contractDetails;\r\n  \r\n  let score = 0;\r\n  \r\n  // Calculate score for made contracts\r\n  if (madeContract) {\r\n    // Base trick score\r\n    let trickScore = 0;\r\n    \r\n    if (suit === '♣' || suit === '♦') {\r\n      // Minor suits: 20 points per trick\r\n      trickScore = level * 20;\r\n    } else if (suit === '♥' || suit === '♠') {\r\n      // Major suits: 30 points per trick\r\n      trickScore = level * 30;\r\n    } else if (suit === 'NT') {\r\n      // No Trump: 40 for first trick, 30 for additional tricks\r\n      trickScore = 40 + (level - 1) * 30;\r\n    }\r\n    \r\n    // Apply doubling if applicable\r\n    if (doubled === 'X') {\r\n      trickScore *= 2;\r\n    } else if (doubled === 'XX') {\r\n      trickScore *= 4;\r\n    }\r\n    \r\n    score += trickScore;\r\n    \r\n    // Add bonus for game contracts (100 non-vul, 120 vul)\r\n    if (score >= 100) {\r\n      score += declarerVulnerable ? 120 : 50;\r\n    } else {\r\n      // Partial contract bonus\r\n      score += 50;\r\n    }\r\n    \r\n    // Slam bonuses\r\n    if (level === 6) {\r\n      // Small slam bonus\r\n      score += declarerVulnerable ? 750 : 500;\r\n    } else if (level === 7) {\r\n      // Grand slam bonus\r\n      score += declarerVulnerable ? 1500 : 1000;\r\n    }\r\n    \r\n    // Doubled/redoubled bonus\r\n    if (doubled === 'X') {\r\n      score += 50;\r\n    } else if (doubled === 'XX') {\r\n      score += 100;\r\n    }\r\n    \r\n    // Overtrick points\r\n    if (result > 0) {\r\n      let overtrickPoints = 0;\r\n      \r\n      if (doubled === 'X') {\r\n        // Doubled overtricks\r\n        overtrickPoints = result * (declarerVulnerable ? 200 : 100);\r\n      } else if (doubled === 'XX') {\r\n        // Redoubled overtricks\r\n        overtrickPoints = result * (declarerVulnerable ? 400 : 200);\r\n      } else {\r\n        // Undoubled overtricks\r\n        if (suit === '♣' || suit === '♦') {\r\n          overtrickPoints = result * 20;\r\n        } else {\r\n          overtrickPoints = result * 30;\r\n        }\r\n      }\r\n      \r\n      score += overtrickPoints;\r\n    }\r\n  } else {\r\n    // Score for defeated contracts\r\n    let undertrickPoints = 0;\r\n    \r\n    if (doubled === 'X') {\r\n      // Doubled undertricks\r\n      if (declarerVulnerable) {\r\n        // Vulnerable doubled undertricks\r\n        undertrickPoints = 200 + (Math.abs(result) - 1) * 300;\r\n      } else {\r\n        // Non-vulnerable doubled undertricks\r\n        undertrickPoints = 100 + (Math.abs(result) > 1 ? 200 : 0) + \r\n                           (Math.abs(result) > 2 ? (Math.abs(result) - 2) * 300 : 0);\r\n      }\r\n    } else if (doubled === 'XX') {\r\n      // Redoubled undertricks (double the doubled undertricks)\r\n      if (declarerVulnerable) {\r\n        undertrickPoints = 400 + (Math.abs(result) - 1) * 600;\r\n      } else {\r\n        undertrickPoints = 200 + (Math.abs(result) > 1 ? 400 : 0) + \r\n                           (Math.abs(result) > 2 ? (Math.abs(result) - 2) * 600 : 0);\r\n      }\r\n    } else {\r\n      // Undoubled undertricks\r\n      undertrickPoints = Math.abs(result) * (declarerVulnerable ? 100 : 50);\r\n    }\r\n    \r\n    score = -undertrickPoints;\r\n  }\r\n  \r\n  // Assign points to the appropriate side\r\n  if (isNS) {\r\n    return {\r\n      nsPoints: madeContract ? score : 0,\r\n      ewPoints: madeContract ? 0 : -score\r\n    };\r\n  } else {\r\n    return {\r\n      nsPoints: madeContract ? 0 : -score,\r\n      ewPoints: madeContract ? score : 0\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Generate a readable vulnerability description\r\n * @param {Object} vulnerable - Vulnerability object with ns and ew properties\r\n * @returns {string} Description of vulnerability\r\n */\r\nexport const vulnerabilityDescription = (vulnerable) => {\r\n  if (!vulnerable) return \"None Vulnerable\";\r\n  \r\n  const nsVul = vulnerable.ns || false;\r\n  const ewVul = vulnerable.ew || false;\r\n  \r\n  if (nsVul && ewVul) return \"All Vulnerable\";\r\n  if (nsVul) return \"NS Vulnerable\";\r\n  if (ewVul) return \"EW Vulnerable\";\r\n  return \"None Vulnerable\";\r\n};\r\n\r\n/**\r\n * Determine vulnerability based on deal number\r\n * @param {number} dealNumber - Current deal number\r\n * @returns {Object} Vulnerability object with ns and ew properties\r\n */\r\nexport const determineVulnerability = (dealNumber) => {\r\n  if (!dealNumber) return { ns: false, ew: false };\r\n  \r\n  // Standard bridge vulnerability rotation based on deal number\r\n  const vulPattern = (dealNumber - 1) % 16;\r\n  \r\n  switch (vulPattern) {\r\n    case 0:\r\n    case 7:\r\n    case 10:\r\n    case 13:\r\n      return { ns: false, ew: false }; // None Vulnerable\r\n    case 1:\r\n    case 4:\r\n    case 11:\r\n    case 14:\r\n      return { ns: true, ew: false }; // NS Vulnerable\r\n    case 2:\r\n    case 5:\r\n    case 8:\r\n    case 15:\r\n      return { ns: false, ew: true }; // EW Vulnerable\r\n    case 3:\r\n    case 6:\r\n    case 9:\r\n    case 12:\r\n      return { ns: true, ew: true }; // Both Vulnerable\r\n    default:\r\n      return { ns: false, ew: false }; // Default to None Vulnerable\r\n  }\r\n};\r\n\r\n/**\r\n * Determine dealer based on deal number\r\n * @param {number} dealNumber - Current deal number\r\n * @returns {string} Dealer position (North, East, South, West)\r\n */\r\nexport const determineDealer = (dealNumber) => {\r\n  const positions = [\"North\", \"East\", \"South\", \"West\"];\r\n  const index = (dealNumber - 1) % 4;\r\n  return positions[index];\r\n};\r\n\r\n/**\r\n * Check if a contract is a game contract\r\n * @param {Object} contractDetails - Contract details from parseContract\r\n * @returns {boolean} True if the contract is a game contract\r\n */\r\nexport const isGameContract = (contractDetails) => {\r\n  if (!contractDetails) return false;\r\n  \r\n  const { level, suit } = contractDetails;\r\n  \r\n  return (\r\n    (level === 3 && suit === 'NT') ||\r\n    (level === 4 && (suit === '♥' || suit === '♠')) ||\r\n    (level === 5 && (suit === '♣' || suit === '♦')) ||\r\n    level >= 6\r\n  );\r\n};\r\n\r\n/**\r\n * Calculate bonus bridge score based on the enhanced scoring system\r\n * @param {Object} contractDetails - Contract details from parseContract\r\n * @param {Object} handAnalysis - Hand analysis data (HCP, distribution, etc.)\r\n * @returns {Object} Bonus bridge scoring object\r\n */\r\nexport const calculateBonusBridgeScore = (contractDetails, handAnalysis) => {\r\n  if (!contractDetails || !handAnalysis) return { nsPoints: 0, ewPoints: 0 };\r\n  \r\n  const {\r\n    level,\r\n    suit,\r\n    isNS,\r\n    declarerVulnerable,\r\n    madeContract,\r\n    result,\r\n    doubled,\r\n    actualTricks,\r\n    requiredTricks\r\n  } = contractDetails;\r\n  \r\n  const {\r\n    totalHCP,\r\n    singletons,\r\n    voids,\r\n    longSuits\r\n  } = handAnalysis;\r\n  \r\n  let declarerPoints = 0;\r\n  let defenderPoints = 0;\r\n  \r\n  // Get standard bridge score for raw score calculation\r\n  const standardScore = calculateBridgeScore(contractDetails);\r\n  \r\n  // Extract raw score (absolute value)\r\n  const rawScore = Math.abs(madeContract ? \r\n                           (isNS ? standardScore.nsPoints : standardScore.ewPoints) : \r\n                           (isNS ? standardScore.ewPoints : standardScore.nsPoints));\r\n  \r\n  if (madeContract) {\r\n    // ***** STEP 1: Calculate Raw Score and Reduce Scale *****\r\n    const initialPoints = rawScore / 20;\r\n    \r\n    // ***** STEP 2: Calculate HCP Advantage *****\r\n    const declarerHCPPercentage = (totalHCP / 40) * 100;\r\n    const defenderHCPPercentage = 100 - declarerHCPPercentage;\r\n    const hcpAdvantage = Math.abs(declarerHCPPercentage - defenderHCPPercentage);\r\n    const advantageSide = declarerHCPPercentage > 50 ? \"declarer\" : \"defender\";\r\n    \r\n    // ***** STEP 3: Apply HCP Adjustment Based on Contract Type *****\r\n    let expectedHCP;\r\n    \r\n    // Determine Expected HCP based on contract type\r\n    if (level <= 2) {\r\n      // Part Scores (1-2 level)\r\n      expectedHCP = 21;\r\n    } else if (level === 3 && suit === 'NT') {\r\n      // 3NT Game\r\n      expectedHCP = 25;\r\n    } else if (level === 4 && (suit === '♥' || suit === '♠')) {\r\n      // 4♥/♠ Game\r\n      expectedHCP = 24;\r\n    } else if (level === 5 && (suit === '♣' || suit === '♦')) {\r\n      // 5♣/♦ Game\r\n      expectedHCP = 27;\r\n    } else if (level === 6) {\r\n      // Small Slams (6 level)\r\n      expectedHCP = 30;\r\n    } else if (level === 7) {\r\n      // Grand Slams (7 level)\r\n      expectedHCP = 32;\r\n    } else {\r\n      // Other levels\r\n      expectedHCP = 21 + (level * 1.5);\r\n    }\r\n    \r\n    // Calculate adjustment\r\n    const hcpAdjustment = (totalHCP - expectedHCP) * 0.75;\r\n    let adjustedPoints = initialPoints;\r\n    \r\n    if (totalHCP > expectedHCP) {\r\n      // If Declarer HCP > Expected HCP: Subtract adjustment\r\n      adjustedPoints -= hcpAdjustment;\r\n    } else if (totalHCP < expectedHCP) {\r\n      // If Declarer HCP < Expected HCP: Add adjustment\r\n      adjustedPoints += Math.abs(hcpAdjustment);\r\n    }\r\n    // No adjustment if Declarer HCP = Expected HCP\r\n    \r\n    // ***** STEP 4: Calculate Expected Tricks *****\r\n    const contractExpectedTricks = requiredTricks;\r\n    const distributionPoints = (voids * 3) + (singletons * 2) + longSuits;\r\n    const handExpectedTricks = Math.min(13, 6 + Math.floor(totalHCP / 3) + Math.floor(distributionPoints / 4));\r\n    \r\n    // ***** STEP 5: Performance Assessment *****\r\n    let performancePoints = adjustedPoints;\r\n    \r\n    // For Contract Performance\r\n    const performanceVariance = actualTricks - contractExpectedTricks;\r\n    if (performanceVariance > 0) {\r\n      // If Variance > 0 (overtricks): Add (Variance × 1.5) points\r\n      performancePoints += (performanceVariance * 1.5);\r\n    }\r\n    \r\n    // For Hand Potential Performance (only if Hand Expected > Contract Expected)\r\n    if (handExpectedTricks > contractExpectedTricks) {\r\n      const potentialVariance = actualTricks - handExpectedTricks;\r\n      if (potentialVariance < 0) {\r\n        // If Potential Variance < 0 (underperformance): Subtract (|Potential Variance| × 0.75) points\r\n        performancePoints -= (Math.abs(potentialVariance) * 0.75);\r\n      }\r\n    }\r\n    \r\n    // ***** STEP 6: Apply Contract Type Adjustments *****\r\n    let contractPoints = performancePoints;\r\n    \r\n    // Check if it's a Game contract\r\n    const isGameContractVal = isGameContract(contractDetails);\r\n    \r\n    if (isGameContractVal) {\r\n      // For Game contracts\r\n      contractPoints += 2;\r\n    }\r\n    \r\n    if (level === 6) {\r\n      // For Small Slam contracts\r\n      contractPoints += 4;\r\n    } else if (level === 7) {\r\n      // For Grand Slam contracts\r\n      contractPoints += 6;\r\n    }\r\n    \r\n    if (suit === 'NT') {\r\n      // For NT contracts\r\n      contractPoints += 1;\r\n    }\r\n    \r\n    const overtricks = actualTricks - contractExpectedTricks;\r\n    \r\n    if (overtricks >= 4) {\r\n      // For contracts with 4+ overtricks\r\n      contractPoints += 1;\r\n      \r\n      if (overtricks >= 7) {\r\n        // For contracts with 7+ overtricks\r\n        contractPoints += 2;\r\n      }\r\n    }\r\n    \r\n    // ***** STEP 7: Distribution Adjustment (Suit Contracts Only) *****\r\n    let finalDeclarerPoints = contractPoints;\r\n    \r\n    if (suit !== 'NT') {\r\n      // Only apply for suit contracts\r\n      if (distributionPoints >= 7) {\r\n        finalDeclarerPoints -= 3;\r\n      } else if (distributionPoints >= 5) {\r\n        finalDeclarerPoints -= 2;\r\n      } else if (distributionPoints >= 3) {\r\n        finalDeclarerPoints -= 1;\r\n      }\r\n      // 1-2 dist points: No deduction\r\n    }\r\n    \r\n    // ***** STEP 8: Defender Reward Calculation *****\r\n    if (handExpectedTricks > contractExpectedTricks && \r\n        actualTricks < handExpectedTricks) {\r\n      // Defender Reward = (Hand Expected Tricks - Actual Tricks) × 2\r\n      const defenderReward = (handExpectedTricks - actualTricks) * 2;\r\n      \r\n      // Extra reward if defending at disadvantage\r\n      const extraReward = Math.min(3, hcpAdvantage / 10);\r\n      \r\n      defenderPoints = defenderReward + (advantageSide === \"declarer\" ? extraReward : 0);\r\n    }\r\n    \r\n    // ***** STEP 9: Finalize Scores *****\r\n    declarerPoints = Math.max(1, Math.round(finalDeclarerPoints)); // Minimum declarer score for made contracts: 1 point\r\n    defenderPoints = Math.round(defenderPoints);\r\n    \r\n  } else {\r\n    // ***** SCORING FOR DEFEATED CONTRACTS *****\r\n    \r\n    // ***** STEP 1: Calculate Base Penalty *****\r\n    const basePenalty = rawScore / 10;\r\n    \r\n    // ***** STEP 2: Add Contract Level Penalties *****\r\n    let levelPenalties = 0;\r\n    \r\n    // Check if it's a Game contract\r\n    const isGameContractVal = isGameContract(contractDetails);\r\n    \r\n    if (isGameContractVal) {\r\n      // For defeated Game contracts\r\n      levelPenalties += 3;\r\n    }\r\n    \r\n    if (level === 6) {\r\n      // For defeated Small Slams\r\n      levelPenalties += 5;\r\n    } else if (level === 7) {\r\n      // For defeated Grand Slams\r\n      levelPenalties += 7;\r\n    }\r\n    \r\n    // ***** STEP 3: Calculate Defender Performance Bonus *****\r\n    let performanceBonus = 0;\r\n    \r\n    const declarerHCPPercentage = (totalHCP / 40) * 100;\r\n    \r\n    if (declarerHCPPercentage > 60) {\r\n      // If Declarer HCP% > 60%\r\n      performanceBonus += (declarerHCPPercentage - 50) / 5;\r\n    }\r\n    \r\n    if (Math.abs(result) >= 2) {\r\n      // If contract defeated by 2+ tricks\r\n      performanceBonus += 2;\r\n      \r\n      if (Math.abs(result) >= 3) {\r\n        // If contract defeated by 3+ tricks\r\n        performanceBonus += 3;\r\n      }\r\n    }\r\n    \r\n    // ***** STEP 4: Calculate Declarer Consolation (Optional) *****\r\n    let consolationPoints = 0;\r\n    \r\n    if (declarerHCPPercentage < 40) {\r\n      // If Declarer HCP% < 40%\r\n      consolationPoints = (50 - declarerHCPPercentage) / 10;\r\n    }\r\n    \r\n    // ***** STEP 5: Finalize Scores for Defeated Contracts *****\r\n    const totalDefenderPoints = basePenalty + levelPenalties + performanceBonus;\r\n    defenderPoints = Math.max(3, Math.round(totalDefenderPoints)); // Minimum defender score: 3 points\r\n    declarerPoints = Math.round(consolationPoints);\r\n  }\r\n  \r\n  // Return final scores for NS and EW\r\n  if (isNS) {\r\n    return {\r\n      nsPoints: madeContract ? declarerPoints : declarerPoints,\r\n      ewPoints: madeContract ? defenderPoints : defenderPoints,\r\n      rawScore\r\n    };\r\n  } else {\r\n    return {\r\n      nsPoints: madeContract ? defenderPoints : defenderPoints,\r\n      ewPoints: madeContract ? declarerPoints : declarerPoints,\r\n      rawScore\r\n    };\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}