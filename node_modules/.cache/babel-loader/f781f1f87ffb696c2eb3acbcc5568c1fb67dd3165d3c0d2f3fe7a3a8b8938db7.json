{"ast":null,"code":"/* Fixed scoring.js with corrected calculations for undertricks */\n\n// Determine vulnerability based on deal number\nexport function determineVulnerability(dealNumber) {\n  // Standard vulnerability rotation in Bridge:\n  // 1: None, 2: NS, 3: EW, 4: Both, 5: None, etc.\n  const rotation = [{\n    ns: false,\n    ew: false\n  },\n  // None\n  {\n    ns: true,\n    ew: false\n  },\n  // NS\n  {\n    ns: false,\n    ew: true\n  },\n  // EW\n  {\n    ns: true,\n    ew: true\n  } // Both\n  ];\n\n  // Use modulo to cycle through vulnerability (subtracting 1 because dealNumber starts at 1)\n  const index = (dealNumber - 1) % 4;\n  return rotation[index];\n}\n\n// Determine vulnerability description\nexport function vulnerabilityDescription(vulnerable) {\n  if (!vulnerable) return \"None Vulnerable\";\n  if (vulnerable.ns && vulnerable.ew) {\n    return \"Both Vulnerable\";\n  } else if (vulnerable.ns) {\n    return \"NS Vulnerable\";\n  } else if (vulnerable.ew) {\n    return \"EW Vulnerable\";\n  } else {\n    return \"None Vulnerable\";\n  }\n}\n\n// Parse contract string into components\nexport function parseContract(contractString, result, vulnerable) {\n  if (!contractString) return null;\n  const match = contractString.match(/(\\d)([♣♦♥♠]|NT)\\s+([NESW])(X{0,2})/);\n  if (!match) return null;\n  const level = parseInt(match[1]);\n  const suit = match[2];\n  const declarer = match[3];\n  const doubled = match[4];\n\n  // Determine if declarer is vulnerable\n  const isNS = declarer === 'N' || declarer === 'S';\n  const isVulnerable = isNS ? (vulnerable === null || vulnerable === void 0 ? void 0 : vulnerable.ns) || false : (vulnerable === null || vulnerable === void 0 ? void 0 : vulnerable.ew) || false;\n\n  // Determine if contract was doubled or redoubled\n  const isDoubled = doubled === 'X';\n  const isRedoubled = doubled === 'XX';\n\n  // Calculate required tricks (level + 6)\n  const requiredTricks = level + 6;\n\n  // Determine the suit type (minor, major, NT)\n  let suitType = '';\n  if (suit === '♣' || suit === '♦') {\n    suitType = 'minor';\n  } else if (suit === '♥' || suit === '♠') {\n    suitType = 'major';\n  } else if (suit === 'NT') {\n    suitType = 'notrump';\n  }\n  return {\n    level,\n    suit,\n    suitType,\n    declarer,\n    isNS,\n    isVulnerable,\n    isDoubled,\n    isRedoubled,\n    requiredTricks,\n    result\n  };\n}\n\n// Calculate bridge score based on contract details - FIXED for undertricks\nexport function calculateBridgeScore(contractDetails) {\n  if (!contractDetails) {\n    return {\n      nsPoints: 0,\n      ewPoints: 0\n    };\n  }\n  const {\n    level,\n    suitType,\n    isNS,\n    isVulnerable,\n    isDoubled,\n    isRedoubled,\n    requiredTricks,\n    result\n  } = contractDetails;\n  let score = 0;\n\n  // Contract was made\n  if (result >= 0) {\n    // Calculate trick score\n    let trickScore = 0;\n    if (suitType === 'minor') {\n      trickScore = level * 20;\n    } else if (suitType === 'major') {\n      trickScore = level * 30;\n    } else if (suitType === 'notrump') {\n      trickScore = 40 + (level - 1) * 30;\n    }\n\n    // Apply doubling multipliers\n    if (isDoubled) {\n      trickScore *= 2;\n    } else if (isRedoubled) {\n      trickScore *= 4;\n    }\n    score += trickScore;\n\n    // Game bonus (if applicable)\n    if (trickScore >= 100) {\n      score += isVulnerable ? 500 : 300;\n    } else {\n      // Part score bonus\n      score += 50;\n    }\n\n    // Slam bonus (if applicable)\n    if (level === 6) {\n      score += isVulnerable ? 750 : 500;\n    } else if (level === 7) {\n      score += isVulnerable ? 1500 : 1000;\n    }\n\n    // Overtrick bonuses\n    if (result > 0) {\n      if (isDoubled) {\n        score += (isVulnerable ? 200 : 100) * result;\n      } else if (isRedoubled) {\n        score += (isVulnerable ? 400 : 200) * result;\n      } else {\n        if (suitType === 'minor') {\n          score += 20 * result;\n        } else if (suitType === 'major') {\n          score += 30 * result;\n        } else {\n          // NT\n          score += 30 * result;\n        }\n      }\n    }\n\n    // Insult bonus for making doubled/redoubled contract\n    if (isDoubled) {\n      score += 50;\n    } else if (isRedoubled) {\n      score += 100;\n    }\n  }\n  // Contract went down - FIXED CALCULATION FOR UNDERTRICKS\n  else {\n    // Calculate undertrick penalties\n    const undertricks = Math.abs(result);\n    if (isDoubled) {\n      if (isVulnerable) {\n        // Vulnerable doubled undertricks - FIXED: All undertricks are 300\n        score = 200; // First undertrick base\n        if (undertricks > 1) {\n          score += 300 * (undertricks - 1); // Each additional undertrick is 300\n        }\n      } else {\n        // Not vulnerable doubled undertricks - FIXED to follow standard scoring\n        score = 100; // First undertrick base\n\n        if (undertricks > 1) {\n          // Second and third undertricks are 200 each\n          const secondAndThird = Math.min(undertricks - 1, 2);\n          score += 200 * secondAndThird;\n\n          // Fourth and beyond are 300 each\n          if (undertricks > 3) {\n            score += 300 * (undertricks - 3);\n          }\n        }\n      }\n    } else if (isRedoubled) {\n      if (isVulnerable) {\n        // Vulnerable redoubled undertricks\n        score = 400; // First undertrick base\n        if (undertricks > 1) {\n          score += 600 * (undertricks - 1); // Each additional undertrick is 600\n        }\n      } else {\n        // Not vulnerable redoubled undertricks\n        score = 200; // First undertrick base\n\n        if (undertricks > 1) {\n          // Second and third undertricks are 400 each\n          const secondAndThird = Math.min(undertricks - 1, 2);\n          score += 400 * secondAndThird;\n\n          // Fourth and beyond are 600 each\n          if (undertricks > 3) {\n            score += 600 * (undertricks - 3);\n          }\n        }\n      }\n    } else {\n      // Undoubled undertricks\n      score = (isVulnerable ? 100 : 50) * undertricks;\n    }\n\n    // For undertricks, the score is negative for the declarer's side\n    score = -score;\n  }\n  console.log(`Score calculation: ${score} points for ${isNS ? 'NS' : 'EW'}`);\n\n  // Return the score assigned to the correct team\n  if (isNS) {\n    if (score > 0) {\n      return {\n        nsPoints: score,\n        ewPoints: 0\n      };\n    } else {\n      return {\n        nsPoints: 0,\n        ewPoints: Math.abs(score)\n      };\n    }\n  } else {\n    if (score > 0) {\n      return {\n        nsPoints: 0,\n        ewPoints: score\n      };\n    } else {\n      return {\n        nsPoints: Math.abs(score),\n        ewPoints: 0\n      };\n    }\n  }\n}\n\n// Calculate the declarer's high card points\nexport function calculateHighCardPoints(cards) {\n  if (!cards || !Array.isArray(cards)) return 0;\n  let points = 0;\n  for (const card of cards) {\n    // Assuming card has a 'value' property (A, K, Q, J, etc.)\n    if (card.value === 'A') points += 4;else if (card.value === 'K') points += 3;else if (card.value === 'Q') points += 2;else if (card.value === 'J') points += 1;\n  }\n  return points;\n}\n\n// Calculate distribution points\nexport function calculateDistributionPoints(cards) {\n  if (!cards || !Array.isArray(cards)) return 0;\n\n  // Count cards by suit\n  const suitCounts = {\n    '♠': 0,\n    '♥': 0,\n    '♦': 0,\n    '♣': 0\n  };\n  for (const card of cards) {\n    // Assuming card has a 'suit' property\n    if (suitCounts.hasOwnProperty(card.suit)) {\n      suitCounts[card.suit]++;\n    }\n  }\n  let distributionPoints = 0;\n\n  // Add points for voids, singletons, and doubletons\n  for (const suit in suitCounts) {\n    if (suitCounts[suit] === 0) distributionPoints += 3; // Void\n    else if (suitCounts[suit] === 1) distributionPoints += 2; // Singleton\n    else if (suitCounts[suit] === 2) distributionPoints += 1; // Doubleton\n  }\n  return distributionPoints;\n}\n\n// Determine dealer based on deal number\nexport function determineDealer(dealNumber) {\n  // In a standard Bridge game, the dealer rotates: North, East, South, West\n  const rotation = ['North', 'East', 'South', 'West'];\n\n  // Use modulo to cycle through dealers (subtracting 1 because dealNumber starts at 1)\n  const index = (dealNumber - 1) % 4;\n  return rotation[index];\n}\n\n// Calculate adjusted score based on high card points and distribution\nexport function calculateAdjustedScore(baseScore, declarerHCP, dummyHCP, distributionPoints) {\n  // Example adjustment formula:\n  // - If HCP for declarer+dummy is 25+, no adjustment\n  // - If HCP is 21-24, award 10% bonus\n  // - If HCP is under 21, award 20% bonus\n  // - Add 5% per distribution point beyond the first two\n\n  const totalHCP = declarerHCP + dummyHCP;\n  let adjustmentFactor = 1.0;\n  if (totalHCP < 21) {\n    adjustmentFactor += 0.2; // 20% bonus\n  } else if (totalHCP < 25) {\n    adjustmentFactor += 0.1; // 10% bonus\n  }\n\n  // Add distribution bonus (beyond first two points)\n  if (distributionPoints > 2) {\n    adjustmentFactor += 0.05 * (distributionPoints - 2);\n  }\n  return Math.round(baseScore * adjustmentFactor);\n}","map":{"version":3,"names":["determineVulnerability","dealNumber","rotation","ns","ew","index","vulnerabilityDescription","vulnerable","parseContract","contractString","result","match","level","parseInt","suit","declarer","doubled","isNS","isVulnerable","isDoubled","isRedoubled","requiredTricks","suitType","calculateBridgeScore","contractDetails","nsPoints","ewPoints","score","trickScore","undertricks","Math","abs","secondAndThird","min","console","log","calculateHighCardPoints","cards","Array","isArray","points","card","value","calculateDistributionPoints","suitCounts","hasOwnProperty","distributionPoints","determineDealer","calculateAdjustedScore","baseScore","declarerHCP","dummyHCP","totalHCP","adjustmentFactor","round"],"sources":["C:/Users/mikec/MikesBridge/bonusbridge/src/utils/scoring.js"],"sourcesContent":["/* Fixed scoring.js with corrected calculations for undertricks */\r\n\r\n// Determine vulnerability based on deal number\r\nexport function determineVulnerability(dealNumber) {\r\n  // Standard vulnerability rotation in Bridge:\r\n  // 1: None, 2: NS, 3: EW, 4: Both, 5: None, etc.\r\n  const rotation = [\r\n    { ns: false, ew: false }, // None\r\n    { ns: true, ew: false },  // NS\r\n    { ns: false, ew: true },  // EW\r\n    { ns: true, ew: true }    // Both\r\n  ];\r\n  \r\n  // Use modulo to cycle through vulnerability (subtracting 1 because dealNumber starts at 1)\r\n  const index = (dealNumber - 1) % 4;\r\n  \r\n  return rotation[index];\r\n}\r\n\r\n// Determine vulnerability description\r\nexport function vulnerabilityDescription(vulnerable) {\r\n  if (!vulnerable) return \"None Vulnerable\";\r\n  \r\n  if (vulnerable.ns && vulnerable.ew) {\r\n    return \"Both Vulnerable\";\r\n  } else if (vulnerable.ns) {\r\n    return \"NS Vulnerable\";\r\n  } else if (vulnerable.ew) {\r\n    return \"EW Vulnerable\";\r\n  } else {\r\n    return \"None Vulnerable\";\r\n  }\r\n}\r\n\r\n// Parse contract string into components\r\nexport function parseContract(contractString, result, vulnerable) {\r\n  if (!contractString) return null;\r\n  \r\n  const match = contractString.match(/(\\d)([♣♦♥♠]|NT)\\s+([NESW])(X{0,2})/);\r\n  if (!match) return null;\r\n  \r\n  const level = parseInt(match[1]);\r\n  const suit = match[2];\r\n  const declarer = match[3];\r\n  const doubled = match[4];\r\n  \r\n  // Determine if declarer is vulnerable\r\n  const isNS = declarer === 'N' || declarer === 'S';\r\n  const isVulnerable = isNS ? \r\n    (vulnerable?.ns || false) : \r\n    (vulnerable?.ew || false);\r\n  \r\n  // Determine if contract was doubled or redoubled\r\n  const isDoubled = doubled === 'X';\r\n  const isRedoubled = doubled === 'XX';\r\n  \r\n  // Calculate required tricks (level + 6)\r\n  const requiredTricks = level + 6;\r\n  \r\n  // Determine the suit type (minor, major, NT)\r\n  let suitType = '';\r\n  if (suit === '♣' || suit === '♦') {\r\n    suitType = 'minor';\r\n  } else if (suit === '♥' || suit === '♠') {\r\n    suitType = 'major';\r\n  } else if (suit === 'NT') {\r\n    suitType = 'notrump';\r\n  }\r\n  \r\n  return {\r\n    level,\r\n    suit,\r\n    suitType,\r\n    declarer,\r\n    isNS,\r\n    isVulnerable,\r\n    isDoubled,\r\n    isRedoubled,\r\n    requiredTricks,\r\n    result\r\n  };\r\n}\r\n\r\n// Calculate bridge score based on contract details - FIXED for undertricks\r\nexport function calculateBridgeScore(contractDetails) {\r\n  if (!contractDetails) {\r\n    return { nsPoints: 0, ewPoints: 0 };\r\n  }\r\n  \r\n  const {\r\n    level,\r\n    suitType,\r\n    isNS,\r\n    isVulnerable,\r\n    isDoubled,\r\n    isRedoubled,\r\n    requiredTricks,\r\n    result\r\n  } = contractDetails;\r\n  \r\n  let score = 0;\r\n  \r\n  // Contract was made\r\n  if (result >= 0) {\r\n    // Calculate trick score\r\n    let trickScore = 0;\r\n    \r\n    if (suitType === 'minor') {\r\n      trickScore = level * 20;\r\n    } else if (suitType === 'major') {\r\n      trickScore = level * 30;\r\n    } else if (suitType === 'notrump') {\r\n      trickScore = 40 + (level - 1) * 30;\r\n    }\r\n    \r\n    // Apply doubling multipliers\r\n    if (isDoubled) {\r\n      trickScore *= 2;\r\n    } else if (isRedoubled) {\r\n      trickScore *= 4;\r\n    }\r\n    \r\n    score += trickScore;\r\n    \r\n    // Game bonus (if applicable)\r\n    if (trickScore >= 100) {\r\n      score += isVulnerable ? 500 : 300;\r\n    } else {\r\n      // Part score bonus\r\n      score += 50;\r\n    }\r\n    \r\n    // Slam bonus (if applicable)\r\n    if (level === 6) {\r\n      score += isVulnerable ? 750 : 500;\r\n    } else if (level === 7) {\r\n      score += isVulnerable ? 1500 : 1000;\r\n    }\r\n    \r\n    // Overtrick bonuses\r\n    if (result > 0) {\r\n      if (isDoubled) {\r\n        score += (isVulnerable ? 200 : 100) * result;\r\n      } else if (isRedoubled) {\r\n        score += (isVulnerable ? 400 : 200) * result;\r\n      } else {\r\n        if (suitType === 'minor') {\r\n          score += 20 * result;\r\n        } else if (suitType === 'major') {\r\n          score += 30 * result;\r\n        } else { // NT\r\n          score += 30 * result;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Insult bonus for making doubled/redoubled contract\r\n    if (isDoubled) {\r\n      score += 50;\r\n    } else if (isRedoubled) {\r\n      score += 100;\r\n    }\r\n  } \r\n  // Contract went down - FIXED CALCULATION FOR UNDERTRICKS\r\n  else {\r\n    // Calculate undertrick penalties\r\n    const undertricks = Math.abs(result);\r\n    \r\n    if (isDoubled) {\r\n      if (isVulnerable) {\r\n        // Vulnerable doubled undertricks - FIXED: All undertricks are 300\r\n        score = 200; // First undertrick base\r\n        if (undertricks > 1) {\r\n          score += 300 * (undertricks - 1); // Each additional undertrick is 300\r\n        }\r\n      } else {\r\n        // Not vulnerable doubled undertricks - FIXED to follow standard scoring\r\n        score = 100; // First undertrick base\r\n        \r\n        if (undertricks > 1) {\r\n          // Second and third undertricks are 200 each\r\n          const secondAndThird = Math.min(undertricks - 1, 2);\r\n          score += 200 * secondAndThird;\r\n          \r\n          // Fourth and beyond are 300 each\r\n          if (undertricks > 3) {\r\n            score += 300 * (undertricks - 3);\r\n          }\r\n        }\r\n      }\r\n    } else if (isRedoubled) {\r\n      if (isVulnerable) {\r\n        // Vulnerable redoubled undertricks\r\n        score = 400; // First undertrick base\r\n        if (undertricks > 1) {\r\n          score += 600 * (undertricks - 1); // Each additional undertrick is 600\r\n        }\r\n      } else {\r\n        // Not vulnerable redoubled undertricks\r\n        score = 200; // First undertrick base\r\n        \r\n        if (undertricks > 1) {\r\n          // Second and third undertricks are 400 each\r\n          const secondAndThird = Math.min(undertricks - 1, 2);\r\n          score += 400 * secondAndThird;\r\n          \r\n          // Fourth and beyond are 600 each\r\n          if (undertricks > 3) {\r\n            score += 600 * (undertricks - 3);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      // Undoubled undertricks\r\n      score = (isVulnerable ? 100 : 50) * undertricks;\r\n    }\r\n    \r\n    // For undertricks, the score is negative for the declarer's side\r\n    score = -score;\r\n  }\r\n  \r\n  console.log(`Score calculation: ${score} points for ${isNS ? 'NS' : 'EW'}`);\r\n  \r\n  // Return the score assigned to the correct team\r\n  if (isNS) {\r\n    if (score > 0) {\r\n      return { nsPoints: score, ewPoints: 0 };\r\n    } else {\r\n      return { nsPoints: 0, ewPoints: Math.abs(score) };\r\n    }\r\n  } else {\r\n    if (score > 0) {\r\n      return { nsPoints: 0, ewPoints: score };\r\n    } else {\r\n      return { nsPoints: Math.abs(score), ewPoints: 0 };\r\n    }\r\n  }\r\n}\r\n\r\n// Calculate the declarer's high card points\r\nexport function calculateHighCardPoints(cards) {\r\n  if (!cards || !Array.isArray(cards)) return 0;\r\n  \r\n  let points = 0;\r\n  \r\n  for (const card of cards) {\r\n    // Assuming card has a 'value' property (A, K, Q, J, etc.)\r\n    if (card.value === 'A') points += 4;\r\n    else if (card.value === 'K') points += 3;\r\n    else if (card.value === 'Q') points += 2;\r\n    else if (card.value === 'J') points += 1;\r\n  }\r\n  \r\n  return points;\r\n}\r\n\r\n// Calculate distribution points\r\nexport function calculateDistributionPoints(cards) {\r\n  if (!cards || !Array.isArray(cards)) return 0;\r\n  \r\n  // Count cards by suit\r\n  const suitCounts = {\r\n    '♠': 0,\r\n    '♥': 0,\r\n    '♦': 0,\r\n    '♣': 0\r\n  };\r\n  \r\n  for (const card of cards) {\r\n    // Assuming card has a 'suit' property\r\n    if (suitCounts.hasOwnProperty(card.suit)) {\r\n      suitCounts[card.suit]++;\r\n    }\r\n  }\r\n  \r\n  let distributionPoints = 0;\r\n  \r\n  // Add points for voids, singletons, and doubletons\r\n  for (const suit in suitCounts) {\r\n    if (suitCounts[suit] === 0) distributionPoints += 3;  // Void\r\n    else if (suitCounts[suit] === 1) distributionPoints += 2;  // Singleton\r\n    else if (suitCounts[suit] === 2) distributionPoints += 1;  // Doubleton\r\n  }\r\n  \r\n  return distributionPoints;\r\n}\r\n\r\n// Determine dealer based on deal number\r\nexport function determineDealer(dealNumber) {\r\n  // In a standard Bridge game, the dealer rotates: North, East, South, West\r\n  const rotation = ['North', 'East', 'South', 'West'];\r\n  \r\n  // Use modulo to cycle through dealers (subtracting 1 because dealNumber starts at 1)\r\n  const index = (dealNumber - 1) % 4;\r\n  \r\n  return rotation[index];\r\n}\r\n\r\n// Calculate adjusted score based on high card points and distribution\r\nexport function calculateAdjustedScore(baseScore, declarerHCP, dummyHCP, distributionPoints) {\r\n  // Example adjustment formula:\r\n  // - If HCP for declarer+dummy is 25+, no adjustment\r\n  // - If HCP is 21-24, award 10% bonus\r\n  // - If HCP is under 21, award 20% bonus\r\n  // - Add 5% per distribution point beyond the first two\r\n  \r\n  const totalHCP = declarerHCP + dummyHCP;\r\n  let adjustmentFactor = 1.0;\r\n  \r\n  if (totalHCP < 21) {\r\n    adjustmentFactor += 0.2;  // 20% bonus\r\n  } else if (totalHCP < 25) {\r\n    adjustmentFactor += 0.1;  // 10% bonus\r\n  }\r\n  \r\n  // Add distribution bonus (beyond first two points)\r\n  if (distributionPoints > 2) {\r\n    adjustmentFactor += 0.05 * (distributionPoints - 2);\r\n  }\r\n  \r\n  return Math.round(baseScore * adjustmentFactor);\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}