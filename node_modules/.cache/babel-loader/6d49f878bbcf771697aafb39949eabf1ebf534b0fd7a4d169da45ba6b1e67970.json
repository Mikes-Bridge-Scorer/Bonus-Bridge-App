{"ast":null,"code":"/**\r\n * Scoring utility functions for BonusBridge\r\n */\n\n// Constants for scoring\nconst SUIT_VALUES = {\n  'C': 20,\n  // Clubs\n  'D': 20,\n  // Diamonds\n  'H': 30,\n  // Hearts\n  'S': 30,\n  // Spades\n  'NT': 40 // No Trump (first trick 40, remaining 30)\n};\n\n/**\r\n * Calculate the raw bridge score based on contract and tricks made\r\n * @param {Object} contract - Contract details (level, suit, doubled, redoubled, vulnerability)\r\n * @param {Number} tricksMade - Number of tricks made\r\n * @returns {Number} Raw score\r\n */\nexport const calculateRawScore = (contract, tricksMade) => {\n  // Return 0 if any required parameter is missing\n  if (!contract || typeof contract.level !== 'number' || !contract.suit || typeof tricksMade !== 'number') {\n    return 0;\n  }\n  const {\n    level,\n    suit,\n    doubled,\n    redoubled,\n    vulnerable\n  } = contract;\n  const tricksRequired = level + 6; // Contract level + 6\n\n  // Check if contract is made or defeated\n  const contractMade = tricksMade >= tricksRequired;\n  if (contractMade) {\n    // Calculate made contract score\n    return calculateMadeScore(level, suit, doubled, redoubled, vulnerable, tricksMade - tricksRequired);\n  } else {\n    // Calculate defeated contract score\n    return calculateDefeatedScore(tricksRequired - tricksMade, doubled, redoubled, vulnerable);\n  }\n};\n\n/**\r\n * Calculate score for a made contract\r\n * @param {Number} level - Contract level (1-7)\r\n * @param {String} suit - Contract suit (C, D, H, S, NT)\r\n * @param {Boolean} doubled - Whether the contract was doubled\r\n * @param {Boolean} redoubled - Whether the contract was redoubled\r\n * @param {Boolean} vulnerable - Whether the declaring side was vulnerable\r\n * @param {Number} overtricks - Number of overtricks\r\n * @returns {Number} Score for making the contract\r\n */\nconst calculateMadeScore = (level, suit, doubled, redoubled, vulnerable, overtricks) => {\n  // Base trick score\n  let score = 0;\n\n  // Calculate trick score\n  if (suit === 'NT') {\n    // No Trump: 40 for first trick, 30 for each additional trick\n    score = 40 + (level - 1) * 30;\n  } else {\n    // Suit contract: multiply level by suit value\n    score = level * SUIT_VALUES[suit];\n  }\n\n  // Apply double/redouble multiplier to trick score\n  if (redoubled) {\n    score *= 4;\n  } else if (doubled) {\n    score *= 2;\n  }\n\n  // Game bonus\n  if (score < 100) {\n    // Part score\n    score += 50;\n  } else {\n    // Game bonus\n    score += vulnerable ? 500 : 300;\n  }\n\n  // Slam bonus\n  if (level === 6) {\n    // Small slam\n    score += vulnerable ? 750 : 500;\n  } else if (level === 7) {\n    // Grand slam\n    score += vulnerable ? 1500 : 1000;\n  }\n\n  // Overtrick bonus\n  if (overtricks > 0) {\n    if (redoubled) {\n      score += overtricks * (vulnerable ? 400 : 200);\n    } else if (doubled) {\n      score += overtricks * (vulnerable ? 200 : 100);\n    } else {\n      score += overtricks * SUIT_VALUES[suit];\n    }\n  }\n\n  // Double/redouble bonus (insult bonus)\n  if (doubled) {\n    score += 50;\n  } else if (redoubled) {\n    score += 100;\n  }\n  return score;\n};\n\n/**\r\n * Calculate score for a defeated contract\r\n * @param {Number} undertricks - Number of undertricks\r\n * @param {Boolean} doubled - Whether the contract was doubled\r\n * @param {Boolean} redoubled - Whether the contract was redoubled\r\n * @param {Boolean} vulnerable - Whether the declaring side was vulnerable\r\n * @returns {Number} Penalty score (negative)\r\n */\nconst calculateDefeatedScore = (undertricks, doubled, redoubled, vulnerable) => {\n  let penalty = 0;\n  if (doubled) {\n    if (vulnerable) {\n      // Vulnerable doubled undertricks\n      if (undertricks === 1) {\n        penalty = 200;\n      } else if (undertricks === 2) {\n        penalty = 500;\n      } else if (undertricks === 3) {\n        penalty = 800;\n      } else {\n        penalty = 800 + (undertricks - 3) * 300;\n      }\n    } else {\n      // Non-vulnerable doubled undertricks\n      if (undertricks === 1) {\n        penalty = 100;\n      } else if (undertricks === 2) {\n        penalty = 300;\n      } else if (undertricks === 3) {\n        penalty = 500;\n      } else {\n        penalty = 500 + (undertricks - 3) * 300;\n      }\n    }\n\n    // Redoubled penalties are twice doubled penalties\n    if (redoubled) {\n      penalty *= 2;\n    }\n  } else {\n    // Undoubled undertricks\n    penalty = undertricks * (vulnerable ? 100 : 50);\n  }\n  return -penalty; // Return negative value for penalties\n};\n\n/**\r\n * Calculate defender bonus based on contract and result\r\n * This is the enhanced BonusBridge scoring feature\r\n * @param {Object} contract - Contract details\r\n * @param {Number} tricksMade - Number of tricks made\r\n * @returns {Number} Defender bonus points\r\n */\nexport const calculateDefenderBonus = (contract, tricksMade) => {\n  if (!contract || typeof contract.level !== 'number' || typeof tricksMade !== 'number') {\n    return 0;\n  }\n  const tricksRequired = contract.level + 6;\n\n  // If contract was made, no bonus for defenders\n  if (tricksMade >= tricksRequired) {\n    return 0;\n  }\n\n  // Calculate bonus based on contract level and undertricks\n  const undertricks = tricksRequired - tricksMade;\n\n  // Base formula: higher contracts give more points when defeated\n  let bonus = contract.level * 10 * undertricks;\n\n  // Apply additional factors based on doubled/redoubled status\n  if (contract.redoubled) {\n    bonus *= 2.5;\n  } else if (contract.doubled) {\n    bonus *= 1.5;\n  }\n\n  // Apply vulnerability factor\n  if (contract.vulnerable) {\n    bonus *= 1.2;\n  }\n  return Math.round(bonus);\n};\n\n/**\r\n * Calculate an advanced score adjustment based on HCP balance\r\n * @param {Object} contract - Contract details\r\n * @param {Number} tricksMade - Number of tricks made\r\n * @param {Number} declarerHCP - Declarer's high card points\r\n * @param {Number} defenderHCP - Defenders' high card points\r\n * @returns {Object} Detailed score adjustment breakdown\r\n */\nexport const calculateAdvancedScoreAdjustment = (contract, tricksMade, declarerHCP, defenderHCP) => {\n  // Return empty adjustment if any parameter is missing\n  if (!contract || typeof tricksMade !== 'number' || typeof declarerHCP !== 'number' || typeof defenderHCP !== 'number') {\n    return {\n      rawScore: 0,\n      declarerBonus: 0,\n      defenderBonus: 0,\n      adjustedScore: 0,\n      analysis: {\n        hcpBalance: {\n          declarer: 50,\n          defender: 50,\n          advantage: 0\n        },\n        expectedTricks: 0,\n        performance: 0\n      }\n    };\n  }\n\n  // Calculate raw score\n  const rawScore = calculateRawScore(contract, tricksMade);\n\n  // Calculate HCP balance\n  const totalHCP = declarerHCP + defenderHCP;\n  const declarerHCPPercentage = Math.round(declarerHCP / totalHCP * 100) || 50;\n  const defenderHCPPercentage = 100 - declarerHCPPercentage;\n  const hcpAdvantage = Math.abs(declarerHCPPercentage - defenderHCPPercentage);\n  const declarerHasAdvantage = declarerHCPPercentage > defenderHCPPercentage;\n\n  // Calculate expected tricks based on HCP distribution\n  const expectedTricks = Math.min(13, Math.max(6, Math.round(6 + declarerHCP / 40 * 7)));\n\n  // Calculate performance (tricks made vs expected)\n  const performance = tricksMade - expectedTricks;\n\n  // Calculate declarer bonus/penalty\n  let declarerBonus = 0;\n  if (performance > 0) {\n    // Reward for overperformance\n    declarerBonus = performance * 10;\n\n    // Extra reward if playing at disadvantage\n    if (!declarerHasAdvantage) {\n      declarerBonus += Math.min(20, hcpAdvantage);\n    }\n  }\n\n  // Calculate defender bonus\n  let defenderBonus = calculateDefenderBonus(contract, tricksMade);\n\n  // Apply HCP advantage/disadvantage factor to defender bonus\n  if (defenderBonus > 0) {\n    if (!declarerHasAdvantage) {\n      // Defenders had stronger hands, reduce bonus\n      defenderBonus = Math.max(0, defenderBonus - Math.round(hcpAdvantage * 2));\n    } else {\n      // Defenders had weaker hands, increase bonus\n      defenderBonus += Math.round(hcpAdvantage * 3);\n    }\n  }\n\n  // Calculate final adjusted score\n  const adjustedScore = rawScore + declarerBonus - defenderBonus;\n\n  // Return detailed adjustment object\n  return {\n    rawScore,\n    declarerBonus,\n    defenderBonus,\n    adjustedScore,\n    analysis: {\n      hcpBalance: {\n        declarer: declarerHCPPercentage,\n        defender: defenderHCPPercentage,\n        advantage: hcpAdvantage,\n        declarerHasAdvantage\n      },\n      expectedTricks,\n      performance\n    }\n  };\n};","map":{"version":3,"names":["SUIT_VALUES","calculateRawScore","contract","tricksMade","level","suit","doubled","redoubled","vulnerable","tricksRequired","contractMade","calculateMadeScore","calculateDefeatedScore","overtricks","score","undertricks","penalty","calculateDefenderBonus","bonus","Math","round","calculateAdvancedScoreAdjustment","declarerHCP","defenderHCP","rawScore","declarerBonus","defenderBonus","adjustedScore","analysis","hcpBalance","declarer","defender","advantage","expectedTricks","performance","totalHCP","declarerHCPPercentage","defenderHCPPercentage","hcpAdvantage","abs","declarerHasAdvantage","min","max"],"sources":["C:/Users/mikec/MikesBridge/bonusbridge/src/utils/scoring.js"],"sourcesContent":["/**\r\n * Scoring utility functions for BonusBridge\r\n */\r\n\r\n// Constants for scoring\r\nconst SUIT_VALUES = {\r\n  'C': 20, // Clubs\r\n  'D': 20, // Diamonds\r\n  'H': 30, // Hearts\r\n  'S': 30, // Spades\r\n  'NT': 40 // No Trump (first trick 40, remaining 30)\r\n};\r\n\r\n/**\r\n * Calculate the raw bridge score based on contract and tricks made\r\n * @param {Object} contract - Contract details (level, suit, doubled, redoubled, vulnerability)\r\n * @param {Number} tricksMade - Number of tricks made\r\n * @returns {Number} Raw score\r\n */\r\nexport const calculateRawScore = (contract, tricksMade) => {\r\n  // Return 0 if any required parameter is missing\r\n  if (!contract || \r\n      typeof contract.level !== 'number' || \r\n      !contract.suit || \r\n      typeof tricksMade !== 'number') {\r\n    return 0;\r\n  }\r\n\r\n  const { level, suit, doubled, redoubled, vulnerable } = contract;\r\n  const tricksRequired = level + 6; // Contract level + 6\r\n  \r\n  // Check if contract is made or defeated\r\n  const contractMade = tricksMade >= tricksRequired;\r\n  \r\n  if (contractMade) {\r\n    // Calculate made contract score\r\n    return calculateMadeScore(level, suit, doubled, redoubled, vulnerable, tricksMade - tricksRequired);\r\n  } else {\r\n    // Calculate defeated contract score\r\n    return calculateDefeatedScore(tricksRequired - tricksMade, doubled, redoubled, vulnerable);\r\n  }\r\n};\r\n\r\n/**\r\n * Calculate score for a made contract\r\n * @param {Number} level - Contract level (1-7)\r\n * @param {String} suit - Contract suit (C, D, H, S, NT)\r\n * @param {Boolean} doubled - Whether the contract was doubled\r\n * @param {Boolean} redoubled - Whether the contract was redoubled\r\n * @param {Boolean} vulnerable - Whether the declaring side was vulnerable\r\n * @param {Number} overtricks - Number of overtricks\r\n * @returns {Number} Score for making the contract\r\n */\r\nconst calculateMadeScore = (level, suit, doubled, redoubled, vulnerable, overtricks) => {\r\n  // Base trick score\r\n  let score = 0;\r\n  \r\n  // Calculate trick score\r\n  if (suit === 'NT') {\r\n    // No Trump: 40 for first trick, 30 for each additional trick\r\n    score = 40 + (level - 1) * 30;\r\n  } else {\r\n    // Suit contract: multiply level by suit value\r\n    score = level * SUIT_VALUES[suit];\r\n  }\r\n  \r\n  // Apply double/redouble multiplier to trick score\r\n  if (redoubled) {\r\n    score *= 4;\r\n  } else if (doubled) {\r\n    score *= 2;\r\n  }\r\n  \r\n  // Game bonus\r\n  if (score < 100) {\r\n    // Part score\r\n    score += 50;\r\n  } else {\r\n    // Game bonus\r\n    score += vulnerable ? 500 : 300;\r\n  }\r\n  \r\n  // Slam bonus\r\n  if (level === 6) {\r\n    // Small slam\r\n    score += vulnerable ? 750 : 500;\r\n  } else if (level === 7) {\r\n    // Grand slam\r\n    score += vulnerable ? 1500 : 1000;\r\n  }\r\n  \r\n  // Overtrick bonus\r\n  if (overtricks > 0) {\r\n    if (redoubled) {\r\n      score += overtricks * (vulnerable ? 400 : 200);\r\n    } else if (doubled) {\r\n      score += overtricks * (vulnerable ? 200 : 100);\r\n    } else {\r\n      score += overtricks * SUIT_VALUES[suit];\r\n    }\r\n  }\r\n  \r\n  // Double/redouble bonus (insult bonus)\r\n  if (doubled) {\r\n    score += 50;\r\n  } else if (redoubled) {\r\n    score += 100;\r\n  }\r\n  \r\n  return score;\r\n};\r\n\r\n/**\r\n * Calculate score for a defeated contract\r\n * @param {Number} undertricks - Number of undertricks\r\n * @param {Boolean} doubled - Whether the contract was doubled\r\n * @param {Boolean} redoubled - Whether the contract was redoubled\r\n * @param {Boolean} vulnerable - Whether the declaring side was vulnerable\r\n * @returns {Number} Penalty score (negative)\r\n */\r\nconst calculateDefeatedScore = (undertricks, doubled, redoubled, vulnerable) => {\r\n  let penalty = 0;\r\n  \r\n  if (doubled) {\r\n    if (vulnerable) {\r\n      // Vulnerable doubled undertricks\r\n      if (undertricks === 1) {\r\n        penalty = 200;\r\n      } else if (undertricks === 2) {\r\n        penalty = 500;\r\n      } else if (undertricks === 3) {\r\n        penalty = 800;\r\n      } else {\r\n        penalty = 800 + (undertricks - 3) * 300;\r\n      }\r\n    } else {\r\n      // Non-vulnerable doubled undertricks\r\n      if (undertricks === 1) {\r\n        penalty = 100;\r\n      } else if (undertricks === 2) {\r\n        penalty = 300;\r\n      } else if (undertricks === 3) {\r\n        penalty = 500;\r\n      } else {\r\n        penalty = 500 + (undertricks - 3) * 300;\r\n      }\r\n    }\r\n    \r\n    // Redoubled penalties are twice doubled penalties\r\n    if (redoubled) {\r\n      penalty *= 2;\r\n    }\r\n  } else {\r\n    // Undoubled undertricks\r\n    penalty = undertricks * (vulnerable ? 100 : 50);\r\n  }\r\n  \r\n  return -penalty; // Return negative value for penalties\r\n};\r\n\r\n/**\r\n * Calculate defender bonus based on contract and result\r\n * This is the enhanced BonusBridge scoring feature\r\n * @param {Object} contract - Contract details\r\n * @param {Number} tricksMade - Number of tricks made\r\n * @returns {Number} Defender bonus points\r\n */\r\nexport const calculateDefenderBonus = (contract, tricksMade) => {\r\n  if (!contract || typeof contract.level !== 'number' || typeof tricksMade !== 'number') {\r\n    return 0;\r\n  }\r\n  \r\n  const tricksRequired = contract.level + 6;\r\n  \r\n  // If contract was made, no bonus for defenders\r\n  if (tricksMade >= tricksRequired) {\r\n    return 0;\r\n  }\r\n  \r\n  // Calculate bonus based on contract level and undertricks\r\n  const undertricks = tricksRequired - tricksMade;\r\n  \r\n  // Base formula: higher contracts give more points when defeated\r\n  let bonus = contract.level * 10 * undertricks;\r\n  \r\n  // Apply additional factors based on doubled/redoubled status\r\n  if (contract.redoubled) {\r\n    bonus *= 2.5;\r\n  } else if (contract.doubled) {\r\n    bonus *= 1.5;\r\n  }\r\n  \r\n  // Apply vulnerability factor\r\n  if (contract.vulnerable) {\r\n    bonus *= 1.2;\r\n  }\r\n  \r\n  return Math.round(bonus);\r\n};\r\n\r\n/**\r\n * Calculate an advanced score adjustment based on HCP balance\r\n * @param {Object} contract - Contract details\r\n * @param {Number} tricksMade - Number of tricks made\r\n * @param {Number} declarerHCP - Declarer's high card points\r\n * @param {Number} defenderHCP - Defenders' high card points\r\n * @returns {Object} Detailed score adjustment breakdown\r\n */\r\nexport const calculateAdvancedScoreAdjustment = (contract, tricksMade, declarerHCP, defenderHCP) => {\r\n  // Return empty adjustment if any parameter is missing\r\n  if (!contract || \r\n      typeof tricksMade !== 'number' || \r\n      typeof declarerHCP !== 'number' || \r\n      typeof defenderHCP !== 'number') {\r\n    return {\r\n      rawScore: 0,\r\n      declarerBonus: 0,\r\n      defenderBonus: 0,\r\n      adjustedScore: 0,\r\n      analysis: { \r\n        hcpBalance: { declarer: 50, defender: 50, advantage: 0 },\r\n        expectedTricks: 0,\r\n        performance: 0\r\n      }\r\n    };\r\n  }\r\n  \r\n  // Calculate raw score\r\n  const rawScore = calculateRawScore(contract, tricksMade);\r\n  \r\n  // Calculate HCP balance\r\n  const totalHCP = declarerHCP + defenderHCP;\r\n  const declarerHCPPercentage = Math.round((declarerHCP / totalHCP) * 100) || 50;\r\n  const defenderHCPPercentage = 100 - declarerHCPPercentage;\r\n  const hcpAdvantage = Math.abs(declarerHCPPercentage - defenderHCPPercentage);\r\n  const declarerHasAdvantage = declarerHCPPercentage > defenderHCPPercentage;\r\n  \r\n  // Calculate expected tricks based on HCP distribution\r\n  const expectedTricks = Math.min(13, Math.max(6, Math.round(6 + (declarerHCP / 40) * 7)));\r\n  \r\n  // Calculate performance (tricks made vs expected)\r\n  const performance = tricksMade - expectedTricks;\r\n  \r\n  // Calculate declarer bonus/penalty\r\n  let declarerBonus = 0;\r\n  if (performance > 0) {\r\n    // Reward for overperformance\r\n    declarerBonus = performance * 10;\r\n    \r\n    // Extra reward if playing at disadvantage\r\n    if (!declarerHasAdvantage) {\r\n      declarerBonus += Math.min(20, hcpAdvantage);\r\n    }\r\n  }\r\n  \r\n  // Calculate defender bonus\r\n  let defenderBonus = calculateDefenderBonus(contract, tricksMade);\r\n  \r\n  // Apply HCP advantage/disadvantage factor to defender bonus\r\n  if (defenderBonus > 0) {\r\n    if (!declarerHasAdvantage) {\r\n      // Defenders had stronger hands, reduce bonus\r\n      defenderBonus = Math.max(0, defenderBonus - Math.round(hcpAdvantage * 2));\r\n    } else {\r\n      // Defenders had weaker hands, increase bonus\r\n      defenderBonus += Math.round(hcpAdvantage * 3);\r\n    }\r\n  }\r\n  \r\n  // Calculate final adjusted score\r\n  const adjustedScore = rawScore + declarerBonus - defenderBonus;\r\n  \r\n  // Return detailed adjustment object\r\n  return {\r\n    rawScore,\r\n    declarerBonus,\r\n    defenderBonus,\r\n    adjustedScore,\r\n    analysis: {\r\n      hcpBalance: {\r\n        declarer: declarerHCPPercentage,\r\n        defender: defenderHCPPercentage,\r\n        advantage: hcpAdvantage,\r\n        declarerHasAdvantage\r\n      },\r\n      expectedTricks,\r\n      performance\r\n    }\r\n  };\r\n};"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA,MAAMA,WAAW,GAAG;EAClB,GAAG,EAAE,EAAE;EAAE;EACT,GAAG,EAAE,EAAE;EAAE;EACT,GAAG,EAAE,EAAE;EAAE;EACT,GAAG,EAAE,EAAE;EAAE;EACT,IAAI,EAAE,EAAE,CAAC;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,GAAGA,CAACC,QAAQ,EAAEC,UAAU,KAAK;EACzD;EACA,IAAI,CAACD,QAAQ,IACT,OAAOA,QAAQ,CAACE,KAAK,KAAK,QAAQ,IAClC,CAACF,QAAQ,CAACG,IAAI,IACd,OAAOF,UAAU,KAAK,QAAQ,EAAE;IAClC,OAAO,CAAC;EACV;EAEA,MAAM;IAAEC,KAAK;IAAEC,IAAI;IAAEC,OAAO;IAAEC,SAAS;IAAEC;EAAW,CAAC,GAAGN,QAAQ;EAChE,MAAMO,cAAc,GAAGL,KAAK,GAAG,CAAC,CAAC,CAAC;;EAElC;EACA,MAAMM,YAAY,GAAGP,UAAU,IAAIM,cAAc;EAEjD,IAAIC,YAAY,EAAE;IAChB;IACA,OAAOC,kBAAkB,CAACP,KAAK,EAAEC,IAAI,EAAEC,OAAO,EAAEC,SAAS,EAAEC,UAAU,EAAEL,UAAU,GAAGM,cAAc,CAAC;EACrG,CAAC,MAAM;IACL;IACA,OAAOG,sBAAsB,CAACH,cAAc,GAAGN,UAAU,EAAEG,OAAO,EAAEC,SAAS,EAAEC,UAAU,CAAC;EAC5F;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,kBAAkB,GAAGA,CAACP,KAAK,EAAEC,IAAI,EAAEC,OAAO,EAAEC,SAAS,EAAEC,UAAU,EAAEK,UAAU,KAAK;EACtF;EACA,IAAIC,KAAK,GAAG,CAAC;;EAEb;EACA,IAAIT,IAAI,KAAK,IAAI,EAAE;IACjB;IACAS,KAAK,GAAG,EAAE,GAAG,CAACV,KAAK,GAAG,CAAC,IAAI,EAAE;EAC/B,CAAC,MAAM;IACL;IACAU,KAAK,GAAGV,KAAK,GAAGJ,WAAW,CAACK,IAAI,CAAC;EACnC;;EAEA;EACA,IAAIE,SAAS,EAAE;IACbO,KAAK,IAAI,CAAC;EACZ,CAAC,MAAM,IAAIR,OAAO,EAAE;IAClBQ,KAAK,IAAI,CAAC;EACZ;;EAEA;EACA,IAAIA,KAAK,GAAG,GAAG,EAAE;IACf;IACAA,KAAK,IAAI,EAAE;EACb,CAAC,MAAM;IACL;IACAA,KAAK,IAAIN,UAAU,GAAG,GAAG,GAAG,GAAG;EACjC;;EAEA;EACA,IAAIJ,KAAK,KAAK,CAAC,EAAE;IACf;IACAU,KAAK,IAAIN,UAAU,GAAG,GAAG,GAAG,GAAG;EACjC,CAAC,MAAM,IAAIJ,KAAK,KAAK,CAAC,EAAE;IACtB;IACAU,KAAK,IAAIN,UAAU,GAAG,IAAI,GAAG,IAAI;EACnC;;EAEA;EACA,IAAIK,UAAU,GAAG,CAAC,EAAE;IAClB,IAAIN,SAAS,EAAE;MACbO,KAAK,IAAID,UAAU,IAAIL,UAAU,GAAG,GAAG,GAAG,GAAG,CAAC;IAChD,CAAC,MAAM,IAAIF,OAAO,EAAE;MAClBQ,KAAK,IAAID,UAAU,IAAIL,UAAU,GAAG,GAAG,GAAG,GAAG,CAAC;IAChD,CAAC,MAAM;MACLM,KAAK,IAAID,UAAU,GAAGb,WAAW,CAACK,IAAI,CAAC;IACzC;EACF;;EAEA;EACA,IAAIC,OAAO,EAAE;IACXQ,KAAK,IAAI,EAAE;EACb,CAAC,MAAM,IAAIP,SAAS,EAAE;IACpBO,KAAK,IAAI,GAAG;EACd;EAEA,OAAOA,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMF,sBAAsB,GAAGA,CAACG,WAAW,EAAET,OAAO,EAAEC,SAAS,EAAEC,UAAU,KAAK;EAC9E,IAAIQ,OAAO,GAAG,CAAC;EAEf,IAAIV,OAAO,EAAE;IACX,IAAIE,UAAU,EAAE;MACd;MACA,IAAIO,WAAW,KAAK,CAAC,EAAE;QACrBC,OAAO,GAAG,GAAG;MACf,CAAC,MAAM,IAAID,WAAW,KAAK,CAAC,EAAE;QAC5BC,OAAO,GAAG,GAAG;MACf,CAAC,MAAM,IAAID,WAAW,KAAK,CAAC,EAAE;QAC5BC,OAAO,GAAG,GAAG;MACf,CAAC,MAAM;QACLA,OAAO,GAAG,GAAG,GAAG,CAACD,WAAW,GAAG,CAAC,IAAI,GAAG;MACzC;IACF,CAAC,MAAM;MACL;MACA,IAAIA,WAAW,KAAK,CAAC,EAAE;QACrBC,OAAO,GAAG,GAAG;MACf,CAAC,MAAM,IAAID,WAAW,KAAK,CAAC,EAAE;QAC5BC,OAAO,GAAG,GAAG;MACf,CAAC,MAAM,IAAID,WAAW,KAAK,CAAC,EAAE;QAC5BC,OAAO,GAAG,GAAG;MACf,CAAC,MAAM;QACLA,OAAO,GAAG,GAAG,GAAG,CAACD,WAAW,GAAG,CAAC,IAAI,GAAG;MACzC;IACF;;IAEA;IACA,IAAIR,SAAS,EAAE;MACbS,OAAO,IAAI,CAAC;IACd;EACF,CAAC,MAAM;IACL;IACAA,OAAO,GAAGD,WAAW,IAAIP,UAAU,GAAG,GAAG,GAAG,EAAE,CAAC;EACjD;EAEA,OAAO,CAACQ,OAAO,CAAC,CAAC;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,sBAAsB,GAAGA,CAACf,QAAQ,EAAEC,UAAU,KAAK;EAC9D,IAAI,CAACD,QAAQ,IAAI,OAAOA,QAAQ,CAACE,KAAK,KAAK,QAAQ,IAAI,OAAOD,UAAU,KAAK,QAAQ,EAAE;IACrF,OAAO,CAAC;EACV;EAEA,MAAMM,cAAc,GAAGP,QAAQ,CAACE,KAAK,GAAG,CAAC;;EAEzC;EACA,IAAID,UAAU,IAAIM,cAAc,EAAE;IAChC,OAAO,CAAC;EACV;;EAEA;EACA,MAAMM,WAAW,GAAGN,cAAc,GAAGN,UAAU;;EAE/C;EACA,IAAIe,KAAK,GAAGhB,QAAQ,CAACE,KAAK,GAAG,EAAE,GAAGW,WAAW;;EAE7C;EACA,IAAIb,QAAQ,CAACK,SAAS,EAAE;IACtBW,KAAK,IAAI,GAAG;EACd,CAAC,MAAM,IAAIhB,QAAQ,CAACI,OAAO,EAAE;IAC3BY,KAAK,IAAI,GAAG;EACd;;EAEA;EACA,IAAIhB,QAAQ,CAACM,UAAU,EAAE;IACvBU,KAAK,IAAI,GAAG;EACd;EAEA,OAAOC,IAAI,CAACC,KAAK,CAACF,KAAK,CAAC;AAC1B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,gCAAgC,GAAGA,CAACnB,QAAQ,EAAEC,UAAU,EAAEmB,WAAW,EAAEC,WAAW,KAAK;EAClG;EACA,IAAI,CAACrB,QAAQ,IACT,OAAOC,UAAU,KAAK,QAAQ,IAC9B,OAAOmB,WAAW,KAAK,QAAQ,IAC/B,OAAOC,WAAW,KAAK,QAAQ,EAAE;IACnC,OAAO;MACLC,QAAQ,EAAE,CAAC;MACXC,aAAa,EAAE,CAAC;MAChBC,aAAa,EAAE,CAAC;MAChBC,aAAa,EAAE,CAAC;MAChBC,QAAQ,EAAE;QACRC,UAAU,EAAE;UAAEC,QAAQ,EAAE,EAAE;UAAEC,QAAQ,EAAE,EAAE;UAAEC,SAAS,EAAE;QAAE,CAAC;QACxDC,cAAc,EAAE,CAAC;QACjBC,WAAW,EAAE;MACf;IACF,CAAC;EACH;;EAEA;EACA,MAAMV,QAAQ,GAAGvB,iBAAiB,CAACC,QAAQ,EAAEC,UAAU,CAAC;;EAExD;EACA,MAAMgC,QAAQ,GAAGb,WAAW,GAAGC,WAAW;EAC1C,MAAMa,qBAAqB,GAAGjB,IAAI,CAACC,KAAK,CAAEE,WAAW,GAAGa,QAAQ,GAAI,GAAG,CAAC,IAAI,EAAE;EAC9E,MAAME,qBAAqB,GAAG,GAAG,GAAGD,qBAAqB;EACzD,MAAME,YAAY,GAAGnB,IAAI,CAACoB,GAAG,CAACH,qBAAqB,GAAGC,qBAAqB,CAAC;EAC5E,MAAMG,oBAAoB,GAAGJ,qBAAqB,GAAGC,qBAAqB;;EAE1E;EACA,MAAMJ,cAAc,GAAGd,IAAI,CAACsB,GAAG,CAAC,EAAE,EAAEtB,IAAI,CAACuB,GAAG,CAAC,CAAC,EAAEvB,IAAI,CAACC,KAAK,CAAC,CAAC,GAAIE,WAAW,GAAG,EAAE,GAAI,CAAC,CAAC,CAAC,CAAC;;EAExF;EACA,MAAMY,WAAW,GAAG/B,UAAU,GAAG8B,cAAc;;EAE/C;EACA,IAAIR,aAAa,GAAG,CAAC;EACrB,IAAIS,WAAW,GAAG,CAAC,EAAE;IACnB;IACAT,aAAa,GAAGS,WAAW,GAAG,EAAE;;IAEhC;IACA,IAAI,CAACM,oBAAoB,EAAE;MACzBf,aAAa,IAAIN,IAAI,CAACsB,GAAG,CAAC,EAAE,EAAEH,YAAY,CAAC;IAC7C;EACF;;EAEA;EACA,IAAIZ,aAAa,GAAGT,sBAAsB,CAACf,QAAQ,EAAEC,UAAU,CAAC;;EAEhE;EACA,IAAIuB,aAAa,GAAG,CAAC,EAAE;IACrB,IAAI,CAACc,oBAAoB,EAAE;MACzB;MACAd,aAAa,GAAGP,IAAI,CAACuB,GAAG,CAAC,CAAC,EAAEhB,aAAa,GAAGP,IAAI,CAACC,KAAK,CAACkB,YAAY,GAAG,CAAC,CAAC,CAAC;IAC3E,CAAC,MAAM;MACL;MACAZ,aAAa,IAAIP,IAAI,CAACC,KAAK,CAACkB,YAAY,GAAG,CAAC,CAAC;IAC/C;EACF;;EAEA;EACA,MAAMX,aAAa,GAAGH,QAAQ,GAAGC,aAAa,GAAGC,aAAa;;EAE9D;EACA,OAAO;IACLF,QAAQ;IACRC,aAAa;IACbC,aAAa;IACbC,aAAa;IACbC,QAAQ,EAAE;MACRC,UAAU,EAAE;QACVC,QAAQ,EAAEM,qBAAqB;QAC/BL,QAAQ,EAAEM,qBAAqB;QAC/BL,SAAS,EAAEM,YAAY;QACvBE;MACF,CAAC;MACDP,cAAc;MACdC;IACF;EACF,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}