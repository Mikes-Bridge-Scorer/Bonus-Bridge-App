{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useEffect } from 'react';\nimport { parseContract, calculateBridgeScore, calculateBonusBridgeScore } from '../utils/scoring';\n\n/**\r\n * Bridge Game Score Processor component\r\n * This component acts as a bridge between the game state and the scoring system\r\n * It processes the current deal and applies the scoring rules\r\n */\nconst ScoreProcessor = ({\n  currentDeal,\n  onScoreCalculated\n}) => {\n  _s();\n  var _currentDeal$vulnerab, _currentDeal$vulnerab2;\n  // Add debug logging\n  useEffect(() => {\n    console.log('ScoreProcessor received deal:', currentDeal);\n  }, [currentDeal]);\n\n  // FIXED: Improved dependency array to ensure score recalculation happens reliably\n  useEffect(() => {\n    // Only process scores if we have a valid contract and result\n    if (currentDeal && currentDeal.contract && currentDeal.result !== null && currentDeal.result !== undefined) {\n      console.log('Processing score for deal:', currentDeal);\n      processDealScore(currentDeal);\n    }\n  }, [currentDeal === null || currentDeal === void 0 ? void 0 : currentDeal.contract, currentDeal === null || currentDeal === void 0 ? void 0 : currentDeal.result, currentDeal === null || currentDeal === void 0 ? void 0 : (_currentDeal$vulnerab = currentDeal.vulnerable) === null || _currentDeal$vulnerab === void 0 ? void 0 : _currentDeal$vulnerab.ns, currentDeal === null || currentDeal === void 0 ? void 0 : (_currentDeal$vulnerab2 = currentDeal.vulnerable) === null || _currentDeal$vulnerab2 === void 0 ? void 0 : _currentDeal$vulnerab2.ew, onScoreCalculated // FIXED: Added callback to dependencies \n  ]);\n\n  // Process the current deal and calculate scores\n  const processDealScore = deal => {\n    // Parse the contract string\n    const contractDetails = parseContract(deal.contract, deal.result, deal.vulnerable);\n    if (!contractDetails) {\n      console.error('Unable to parse contract', deal.contract);\n      return;\n    }\n\n    // Calculate standard bridge score\n    const standardScore = calculateBridgeScore(contractDetails);\n    console.log('Standard bridge score calculated:', standardScore);\n\n    // If we have HCP data, calculate bonus bridge score\n    let bonusScore = standardScore;\n    if (deal.handAnalysis) {\n      bonusScore = calculateBonusBridgeScore(contractDetails, deal.handAnalysis);\n      console.log('Bonus bridge score calculated:', bonusScore);\n    }\n\n    // Determine which score to use based on the scoring mode\n    const finalScore = deal.bonusScoringEnabled ? bonusScore : standardScore;\n\n    // Calculate raw score - the maximum absolute value of NS or EW points\n    const rawScore = Math.max(Math.abs(finalScore.nsPoints || 0), Math.abs(finalScore.ewPoints || 0));\n    console.log('Raw score calculated:', rawScore);\n\n    // FIXED: Ensure we always have defined scores to prevent undefined values\n    const nsPoints = finalScore.nsPoints || 0;\n    const ewPoints = finalScore.ewPoints || 0;\n\n    // Format the score for sending to parent component\n    const scoreResult = {\n      nsPoints: nsPoints,\n      ewPoints: ewPoints,\n      rawScore: rawScore,\n      bonusScoringEnabled: deal.bonusScoringEnabled || false,\n      handAnalysis: deal.handAnalysis || null,\n      madeContract: contractDetails.madeContract\n    };\n    console.log('Final score result:', scoreResult);\n\n    // Make sure we're passing zero instead of undefined/null\n    if (isNaN(scoreResult.nsPoints)) scoreResult.nsPoints = 0;\n    if (isNaN(scoreResult.ewPoints)) scoreResult.ewPoints = 0;\n    if (isNaN(scoreResult.rawScore)) scoreResult.rawScore = 0;\n\n    // FIXED: Added additional debug logging\n    console.log('Score calculation complete for deal:', deal.dealNumber);\n    console.log('NS Points:', scoreResult.nsPoints);\n    console.log('EW Points:', scoreResult.ewPoints);\n    console.log('Raw Score:', scoreResult.rawScore);\n\n    // Send the calculated score to the parent component\n    onScoreCalculated(scoreResult);\n  };\n\n  // This is a utility component, so it doesn't render anything\n  return null;\n};\n_s(ScoreProcessor, \"3ubReDTFssvu4DHeldAg55cW/CI=\");\n_c = ScoreProcessor;\nexport default ScoreProcessor;\nvar _c;\n$RefreshReg$(_c, \"ScoreProcessor\");","map":{"version":3,"names":["React","useEffect","parseContract","calculateBridgeScore","calculateBonusBridgeScore","ScoreProcessor","currentDeal","onScoreCalculated","_s","_currentDeal$vulnerab","_currentDeal$vulnerab2","console","log","contract","result","undefined","processDealScore","vulnerable","ns","ew","deal","contractDetails","error","standardScore","bonusScore","handAnalysis","finalScore","bonusScoringEnabled","rawScore","Math","max","abs","nsPoints","ewPoints","scoreResult","madeContract","isNaN","dealNumber","_c","$RefreshReg$"],"sources":["C:/Users/mikec/MikesBridge/bonusbridge/src/components/ScoreProcessor.js"],"sourcesContent":["import React, { useEffect } from 'react';\r\nimport { \r\n  parseContract, \r\n  calculateBridgeScore, \r\n  calculateBonusBridgeScore\r\n} from '../utils/scoring';\r\n\r\n/**\r\n * Bridge Game Score Processor component\r\n * This component acts as a bridge between the game state and the scoring system\r\n * It processes the current deal and applies the scoring rules\r\n */\r\nconst ScoreProcessor = ({ currentDeal, onScoreCalculated }) => {\r\n  // Add debug logging\r\n  useEffect(() => {\r\n    console.log('ScoreProcessor received deal:', currentDeal);\r\n  }, [currentDeal]);\r\n  \r\n  // FIXED: Improved dependency array to ensure score recalculation happens reliably\r\n  useEffect(() => {\r\n    // Only process scores if we have a valid contract and result\r\n    if (currentDeal && currentDeal.contract && currentDeal.result !== null && currentDeal.result !== undefined) {\r\n      console.log('Processing score for deal:', currentDeal);\r\n      processDealScore(currentDeal);\r\n    }\r\n  }, [\r\n    currentDeal?.contract, \r\n    currentDeal?.result, \r\n    currentDeal?.vulnerable?.ns, \r\n    currentDeal?.vulnerable?.ew,\r\n    onScoreCalculated  // FIXED: Added callback to dependencies \r\n  ]);\r\n  \r\n  // Process the current deal and calculate scores\r\n  const processDealScore = (deal) => {\r\n    // Parse the contract string\r\n    const contractDetails = parseContract(deal.contract, deal.result, deal.vulnerable);\r\n    \r\n    if (!contractDetails) {\r\n      console.error('Unable to parse contract', deal.contract);\r\n      return;\r\n    }\r\n    \r\n    // Calculate standard bridge score\r\n    const standardScore = calculateBridgeScore(contractDetails);\r\n    console.log('Standard bridge score calculated:', standardScore);\r\n    \r\n    // If we have HCP data, calculate bonus bridge score\r\n    let bonusScore = standardScore;\r\n    \r\n    if (deal.handAnalysis) {\r\n      bonusScore = calculateBonusBridgeScore(contractDetails, deal.handAnalysis);\r\n      console.log('Bonus bridge score calculated:', bonusScore);\r\n    }\r\n    \r\n    // Determine which score to use based on the scoring mode\r\n    const finalScore = deal.bonusScoringEnabled ? bonusScore : standardScore;\r\n    \r\n    // Calculate raw score - the maximum absolute value of NS or EW points\r\n    const rawScore = Math.max(\r\n      Math.abs(finalScore.nsPoints || 0), \r\n      Math.abs(finalScore.ewPoints || 0)\r\n    );\r\n    \r\n    console.log('Raw score calculated:', rawScore);\r\n    \r\n    // FIXED: Ensure we always have defined scores to prevent undefined values\r\n    const nsPoints = finalScore.nsPoints || 0;\r\n    const ewPoints = finalScore.ewPoints || 0;\r\n    \r\n    // Format the score for sending to parent component\r\n    const scoreResult = {\r\n      nsPoints: nsPoints,\r\n      ewPoints: ewPoints,\r\n      rawScore: rawScore,\r\n      bonusScoringEnabled: deal.bonusScoringEnabled || false,\r\n      handAnalysis: deal.handAnalysis || null,\r\n      madeContract: contractDetails.madeContract\r\n    };\r\n    \r\n    console.log('Final score result:', scoreResult);\r\n    \r\n    // Make sure we're passing zero instead of undefined/null\r\n    if (isNaN(scoreResult.nsPoints)) scoreResult.nsPoints = 0;\r\n    if (isNaN(scoreResult.ewPoints)) scoreResult.ewPoints = 0;\r\n    if (isNaN(scoreResult.rawScore)) scoreResult.rawScore = 0;\r\n    \r\n    // FIXED: Added additional debug logging\r\n    console.log('Score calculation complete for deal:', deal.dealNumber);\r\n    console.log('NS Points:', scoreResult.nsPoints);\r\n    console.log('EW Points:', scoreResult.ewPoints);\r\n    console.log('Raw Score:', scoreResult.rawScore);\r\n    \r\n    // Send the calculated score to the parent component\r\n    onScoreCalculated(scoreResult);\r\n  };\r\n  \r\n  // This is a utility component, so it doesn't render anything\r\n  return null;\r\n};\r\n\r\nexport default ScoreProcessor;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}